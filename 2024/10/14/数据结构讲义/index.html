<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">
 


  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Nullptr" />
  <meta name="robots" content="noindex, nofollow"/>
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  
  
  <title>
    
      数据结构讲义 
      
      
      |
    
     Nullptr
  </title>

  
    <link rel="apple-touch-icon" href="/images/Sunflower.png">
    <link rel="icon" href="/images/Sunflower.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Nullptr" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/Sunflower.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Nullptr</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">数据结构讲义</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
          2024-10-14 17:56:01
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="分类"></i>
                
                <span class="span--category">
                  <a href="/categories/%E5%AD%A6%E7%82%B9%E4%BB%80%E4%B9%88/" title="学点什么">
                    <b>#</b> 学点什么
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h1>基本概念</h1>
<ul>
<li>空间使用<br>
函数PrintN，使得传入一个正整数为N的参数后，打印从1到N的全部正整数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：循环实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintN_1</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=N; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：递归实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintN</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (N)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintN(N - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>算法效率<br>
多项式 f(x) = a0 + a1*x^1 +… +an * x^n</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p += (a[i] * <span class="built_in">pow</span>(x, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> p = a[n];</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        p = a[i - <span class="number">1</span>] + x * p;  <span class="comment">// f(x) = a0+ x(a1+x(...(an-1 + x(an))...))</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计时<br>
CLK_TCK 为常数，机器始终每秒所走的打点数 Use CLOCKS_PER_SEC instead of CLK_TCK on mac<br>
include &lt;time.h&gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10 <span class="comment">// 9阶多项式的最大项数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> start, stop;  <span class="comment">//clock()返回的变量类型是 clock_t</span></span><br><span class="line"><span class="type">double</span> duration;  <span class="comment">//秒</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">double</span> a[MAXN];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;MAXN; i++) a[i] = (<span class="type">double</span>)i;  <span class="comment">// 假定每一项系数就是i</span></span><br><span class="line"></span><br><span class="line">	start = clock();</span><br><span class="line">	f1(MAXN<span class="number">-1</span>, a, <span class="number">1.1</span>); <span class="comment">// 假定 x=1.1</span></span><br><span class="line">	stop = clock();</span><br><span class="line">	duration = (<span class="type">double</span>)(stop -  start)/CLOCKS_PER_SEC; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ticks1 = %f\n&quot;</span>, (<span class="type">double</span>)(stop -  start));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;duration1 = %6.2e\n&quot;</span>, duration);</span><br><span class="line"></span><br><span class="line">	start = clock();</span><br><span class="line">	f2(MAXN<span class="number">-1</span>, a, <span class="number">1.1</span>); <span class="comment">// 假定 x=1.1</span></span><br><span class="line">	stop = clock();</span><br><span class="line">	duration = (<span class="type">double</span>)(stop -  start)/CLOCKS_PER_SEC;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ticks2 = %f\n&quot;</span>, (<span class="type">double</span>)(stop -  start));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;duration2 = %6.2e\n&quot;</span>, duration);  <span class="comment">// 要占6位，小数点后2位，以e指数的形式输出</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p += (a[i] * <span class="built_in">pow</span>(x, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> p = a[n];</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        p = a[i - <span class="number">1</span>] + x * p;  <span class="comment">// f(x) = a0+ x(a1+x(...(an-1 + x(an))...))</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>抽象数据类型 Abstract Data Type</h1>
<p>数据类型，包含：数据对象集、数据集合相关联操作集。</p>
<p>抽象指，描述数据类型的方法不依赖于具体实现。 与存放数据的机器、物理结、编程语言构等无关。</p>
<ul>
<li>类型名称：矩阵</li>
<li>数据对象集：M*N</li>
<li>操作集：…</li>
</ul>
<h1>算法</h1>
<p>空间复杂度S(n)<br>
时间复杂度T(n)<br>
多项式算法一：<br>
(1+2+3+…+n) = (n^2 + n) /2<br>
T(n) = C1n^2 + c2n<br>
方法二： T(n) = Cn</p>
<p>最坏情况负责度<br>
平均复杂度</p>
<p>复杂度渐进表示<br>
上界：T(n) = O(f(n)), 存在T(n) &lt;= Cf(n)<br>
下界： T(n) = Omega(g(n))， 存在T(n) &gt;= Cg(n)</p>
<h1>实例： 最大子列和问题</h1>
<h3 id="算法一：">算法一：</h3>
<p>举例{1,2,3,4}<br>
sum = 1<br>
sum = 1 + 2<br>
sum = 1 + 2 + 3<br>
sum = 1 + 2 + 3 + 4<br>
sum = 2<br>
sum = 2 + 3<br>
sum = 2 + 3 + 4<br>
sum = 3<br>
sum  = 3 + 4<br>
sum = 4</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MaxSubseqSum1</span><span class="params">( <span class="type">int</span> A[], <span class="type">int</span> N )</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">int</span> ThisSum, MaxSum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; N; i++ ) </span><br><span class="line">    &#123; </span><br><span class="line">		<span class="keyword">for</span>( j = i; j &lt; N; j++ ) </span><br><span class="line">        &#123; </span><br><span class="line">			ThisSum = <span class="number">0</span>; </span><br><span class="line">			<span class="keyword">for</span>( k = i; k &lt;= j; k++ )</span><br><span class="line">				ThisSum += A[k];</span><br><span class="line">			<span class="keyword">if</span>( ThisSum &gt; MaxSum ) </span><br><span class="line">				MaxSum = ThisSum; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T(N) =  O(N^3)</p>
<h3 id="算法二-去掉K这个循环">算法二, 去掉K这个循环</h3>
<p>举例{1,2,3,4}<br>
sum = 1<br>
sum = sum_previous + 2<br>
sum = sum_previous + 3<br>
sum = sum_previous + 4<br>
sum = 2<br>
sum = sum_previous + 3<br>
sum = sum_previous + 4<br>
sum = 3<br>
sum = sum_previous + 4<br>
sum = 4</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MaxSubseqSum2</span><span class="params">( <span class="type">int</span> A[], <span class="type">int</span> N )</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">int</span> ThisSum, MaxSum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; N; i++ ) </span><br><span class="line">    &#123;</span><br><span class="line">		ThisSum = <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">for</span>( j = i; j &lt; N; j++ ) </span><br><span class="line">		&#123; </span><br><span class="line">			ThisSum += A[j];</span><br><span class="line">            <span class="keyword">if</span>( ThisSum &gt; MaxSum ) </span><br><span class="line">				MaxSum = ThisSum; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>T(N) =  O(N^2)</p>
<h3 id="算法三：-分而治之">算法三： <strong>分而治之</strong></h3>
<p>T(N) = O(NlogN)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Max3</span><span class="params">( <span class="type">int</span> A, <span class="type">int</span> B, <span class="type">int</span> C )</span></span><br><span class="line">&#123; <span class="comment">/* 返回3个整数中的最大值 */</span></span><br><span class="line">    <span class="keyword">return</span> A &gt; B ? A &gt; C ? A : C : B &gt; C ? B : C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">DivideAndConquer</span><span class="params">( <span class="type">int</span> List[], <span class="type">int</span> left, <span class="type">int</span> right )</span></span><br><span class="line">&#123; <span class="comment">/* 分治法求List[left]到List[right]的最大子列和 */</span></span><br><span class="line">    <span class="type">int</span> MaxLeftSum, MaxRightSum; <span class="comment">/* 存放左右子问题的解 */</span></span><br><span class="line">    <span class="type">int</span> MaxLeftBorderSum, MaxRightBorderSum; <span class="comment">/*存放跨分界线的结果*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> LeftBorderSum, RightBorderSum;</span><br><span class="line">    <span class="type">int</span> center, i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( left == right )  </span><br><span class="line">    &#123; <span class="comment">/* 递归的终止条件，子列只有1个数字 */</span></span><br><span class="line">        <span class="keyword">if</span>( List[left] &gt; <span class="number">0</span> ) </span><br><span class="line">        &#123; </span><br><span class="line">        	<span class="comment">// printf(&quot;List[left]=%d\n&quot;, List[left]);</span></span><br><span class="line">        	<span class="keyword">return</span> List[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 下面是&quot;分&quot;的过程 */</span></span><br><span class="line">    <span class="comment">// printf(&quot;left=%d\n&quot;, left);</span></span><br><span class="line">    <span class="comment">// printf(&quot;right=%d\n&quot;, right);</span></span><br><span class="line">    center = ( left + right ) / <span class="number">2</span>; <span class="comment">/* 找到中分点 */</span></span><br><span class="line">    <span class="comment">// printf(&quot;center=%d\n&quot;, center);</span></span><br><span class="line">    <span class="comment">/* 递归求得两边子列的最大和 */</span></span><br><span class="line">    MaxLeftSum = DivideAndConquer( List, left, center );</span><br><span class="line">    <span class="comment">// printf(&quot;MaxLeftSum=%d\n&quot;, MaxLeftSum);</span></span><br><span class="line">    MaxRightSum = DivideAndConquer( List, center+<span class="number">1</span>, right );</span><br><span class="line">    <span class="comment">// printf(&quot;MaxRightSum=%d\n&quot;, MaxRightSum);</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 下面求跨分界线的最大子列和 */</span></span><br><span class="line">    MaxLeftBorderSum = <span class="number">0</span>; LeftBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( i=center; i&gt;=left; i-- ) </span><br><span class="line">    &#123; <span class="comment">/* 从中线向左扫描 */</span></span><br><span class="line">        LeftBorderSum += List[i];</span><br><span class="line">        <span class="comment">// printf(&quot;LeftBorderSum=%d\n&quot;, LeftBorderSum);</span></span><br><span class="line">        <span class="keyword">if</span>( LeftBorderSum &gt; MaxLeftBorderSum )</span><br><span class="line">        &#123;</span><br><span class="line">            MaxLeftBorderSum = LeftBorderSum;</span><br><span class="line">            <span class="comment">// printf(&quot;MaxLeftBorderSum=%d\n&quot;, MaxLeftBorderSum);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/* 左边扫描结束 */</span></span><br><span class="line"> </span><br><span class="line">    MaxRightBorderSum = <span class="number">0</span>; RightBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( i=center+<span class="number">1</span>; i&lt;=right; i++ ) </span><br><span class="line">    &#123; <span class="comment">/* 从中线向右扫描 */</span></span><br><span class="line">        RightBorderSum += List[i];</span><br><span class="line">        <span class="comment">// printf(&quot;RightBorderSum=%d\n&quot;, RightBorderSum);</span></span><br><span class="line">        <span class="keyword">if</span>( RightBorderSum &gt; MaxRightBorderSum )</span><br><span class="line">        &#123;</span><br><span class="line">            MaxRightBorderSum = RightBorderSum;</span><br><span class="line">            <span class="comment">// printf(&quot;MaxRightBorderSum=%d\n&quot;, MaxRightBorderSum);</span></span><br><span class="line">        	</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125; <span class="comment">/* 右边扫描结束 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 下面返回&quot;治&quot;的结果 */</span></span><br><span class="line">    <span class="type">int</span> Max = Max3( MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);</span><br><span class="line">    <span class="comment">// printf(&quot;Max=%d\n&quot;, Max);</span></span><br><span class="line">    <span class="keyword">return</span> Max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">MaxSubseqSum3</span><span class="params">( <span class="type">int</span> List[], <span class="type">int</span> N )</span></span><br><span class="line">&#123; <span class="comment">/* 保持与前2种算法相同的函数接口 */</span></span><br><span class="line">    <span class="keyword">return</span> DivideAndConquer( List, <span class="number">0</span>, N<span class="number">-1</span> );</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="算法四：-在线处理">算法四： <strong>在线处理</strong></h3>
<p>每一个数据进行即时处理，在任何一个地方输入种植，都给出当前的解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MaxSubseqSum4</span><span class="params">( <span class="type">int</span> A[], <span class="type">int</span> N )</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">int</span> ThisSum, MaxSum;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	ThisSum = MaxSum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; N; i++ ) &#123;</span><br><span class="line">		ThisSum += A[i]; <span class="comment">/* 向右累加 */</span> </span><br><span class="line">		<span class="keyword">if</span>( ThisSum &gt; MaxSum )</span><br><span class="line">			MaxSum = ThisSum; <span class="comment">/* 发现更大和则更新当前结果 */</span> </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>( ThisSum &lt; <span class="number">0</span> ) <span class="comment">/* 如果当前子列和为负 */</span></span><br><span class="line">			ThisSum = <span class="number">0</span>; <span class="comment">/* 则不可能使后面的部分和增大，抛弃之 */</span> &#125;</span><br><span class="line">	<span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>线性结构</h1>
<p>一元多项式</p>
<p>$$f(x) = a_0 + a_1x+…+a_nx$$</p>
<p>方法一：顺序存储结构直接表示<br>
a[i]: 系数</p>
<p>方法二：顺序存储表示非零项<br>
用结构数组表示：系数与指数的二元组</p>
<p>方法三：链表结构存储非零项<br>
coef expon link;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">polynomial</span>;</span></span><br><span class="line">truct PolyNode&#123;</span><br><span class="line">   <span class="type">int</span> coef;</span><br><span class="line">   <span class="type">int</span> expon;</span><br><span class="line">   polynomial link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性表-Linear-List">线性表 Linear List</h2>
<p>同类型数据元素构成有序序列的线性结构。<br>
数据对象集：n个元素构成的有序序列<br>
操作集：线性表L属于List, 整数表示位置，元素x属于ElementType。操作：</p>
<ul>
<li>List MakeEmpty(): 初始化一个空表</li>
<li>ElementType FindKth(int K, List L); 根据位序K，返回相应元素</li>
<li>int Find(ElementType x, List L);  在表中查找X第一次出现的位置</li>
<li>void insert(ElementType X, int i, List L); 插入</li>
<li>void Delete(int i, List l);  删除</li>
<li>int length(List L); 返回长度</li>
</ul>
<h2 id="线性存储序列的实现">线性存储序列的实现</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">   ElementType Data[MAXSIZE];</span><br><span class="line">   <span class="type">int</span> Last; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">L</span>;</span> </span><br><span class="line">List PtrL;</span><br></pre></td></tr></table></figure>
<p>访问元素：L.Data[i] or PtrL-&gt;Data[i]<br>
线性表的长度:L.Last+1 或 PtrL-&gt;Last+1  (last代表位置，因为从零开始所以是n-1)</p>
<ul>
<li>初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List <span class="title function_">MakeEmpty</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   List PtrL;</span><br><span class="line">   PtrL = (List )<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode) );  </span><br><span class="line">   PtrL-&gt;Last = <span class="number">-1</span>; <span class="comment">//last若为0 则表示表里有一个元素在0号位置</span></span><br><span class="line">   <span class="keyword">return</span> PtrL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查找</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">( ElementType X, List PtrL )</span> &#123; </span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>( i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!= X ) </span><br><span class="line">      i++;</span><br><span class="line">   <span class="keyword">if</span> (i &gt; PtrL-&gt;Last) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">   <span class="comment">/* 如果没找到，返回-1(因破坏第一个条件而跳出循环) */</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> i; <span class="comment">/* 找到后返回的是存储位置 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均查找次数(n +1)/2，平均时间性能为 O(n)</p>
<ul>
<li>插入<br>
第 i (1≤i≤n+1)个位置上插入一个值为X的新元素（其实是插在数组的第i-1个位置，因为数组从0开始标）先移动再插入，n挪到n+1，n-1挪到n, …，i-1挪到i<br>
在链表L中的第一个位置插入元素X，如下，MAXSIZE代表链表的size</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">( ElementType X, <span class="type">int</span> i, List PtrL )</span> &#123; </span><br><span class="line">   <span class="type">int</span> j;</span><br><span class="line">   <span class="comment">/* 表空间已满，不能插入*/</span></span><br><span class="line">   <span class="keyword">if</span> ( PtrL-&gt;Last == MAXSIZE<span class="number">-1</span> )</span><br><span class="line">   &#123; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;表满&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*检查插入位置的合法性*/</span></span><br><span class="line">   <span class="keyword">if</span> ( i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last+<span class="number">2</span>) </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;位置不合法&quot;</span>); </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 开始挪位子，从最后的一位last开始直到i-1 */</span></span><br><span class="line">   <span class="keyword">for</span> ( j = PtrL-&gt;Last; j &gt;= i<span class="number">-1</span>; j-- )</span><br><span class="line">      PtrL-&gt;Data[j+<span class="number">1</span>] = PtrL-&gt;Data[j]; </span><br><span class="line">   </span><br><span class="line">   PtrL-&gt;Data[i<span class="number">-1</span>] = X; <span class="comment">/*新元素插入*/</span> </span><br><span class="line">   PtrL-&gt;Last++; <span class="comment">/*Last仍指向最后元素*/</span> </span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均移动次数为 n /2，<br>
/<em>检查插入位置的合法性</em>/ 平均时间性能为 O(n)</p>
<ul>
<li>删除<br>
删除第i个位置上的元素，i在1到n之间，对应数组下表0到n-1<br>
删掉下表为i-1的元素，下标i的元素挪到i-1…</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">( <span class="type">int</span> i, List PtrL )</span> </span><br><span class="line">&#123; </span><br><span class="line">   intj;</span><br><span class="line">   <span class="comment">/*检查空表及删除位置的合法性*/</span></span><br><span class="line">   <span class="keyword">if</span>( i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last+<span class="number">1</span> ) </span><br><span class="line">   &#123; </span><br><span class="line">   <span class="built_in">printf</span> (“不存在第%d个元素”, i );</span><br><span class="line">   <span class="keyword">return</span> ; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*将 ai+1~ an顺序向前移动, 从第i位开始，到last */</span></span><br><span class="line">   <span class="keyword">for</span> ( j = i; j &lt;= PtrL-&gt;Last; j++ ) </span><br><span class="line">      PtrL-&gt;Data[j<span class="number">-1</span>] = PtrL-&gt;Data[j];</span><br><span class="line">      </span><br><span class="line">   PtrL-&gt;Last--; <span class="comment">/*Last仍指向最后元素*/</span></span><br><span class="line">   <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均移动次数为 (n-1) /2<br>
平均时间性能为 O(n)</p>
<h2 id="链式存储的实现">链式存储的实现</h2>
<p>一个线性表用数组存储的时候，相邻的元素不仅逻辑上不仅逻辑上相邻，物理上也是相邻的。而链表通过链连接，建立数据元素的逻辑关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ElementType Data;</span><br><span class="line">   List Next; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> <span class="title">L</span>;</span> </span><br><span class="line">List PtrL;</span><br></pre></td></tr></table></figure>
<ul>
<li>求表长<br>
用临时指针p指向链表头Ptrl，然后遍历，直到null</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span> <span class="params">( List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">   List p = PtrL;  <span class="comment">/* p指向表的第一个结点*/</span></span><br><span class="line">   <span class="type">int</span> j=<span class="number">0</span>; </span><br><span class="line">   <span class="keyword">while</span> ( p ) </span><br><span class="line">   &#123;</span><br><span class="line">      p = p-&gt;Next; </span><br><span class="line">      j++;  <span class="comment">/* 当前p指向的是第 j 个结点*/</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> j; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查找</li>
</ul>
<ol>
<li>按序号查找 根据位序K，返回相应元素 FindKth(int K, List L)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List <span class="title function_">FindKth</span><span class="params">( <span class="type">int</span> K, List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">   List p = PtrL;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">1</span>;  <span class="comment">// i代表第几给元素。因为一开始p指向第一个元素，所以i=1</span></span><br><span class="line">   <span class="keyword">while</span> (p !=<span class="literal">NULL</span> &amp;&amp; i &lt; K )</span><br><span class="line">   &#123;</span><br><span class="line">      p = p-&gt;Next;</span><br><span class="line">      i++; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( i == K ) <span class="comment">/* 找到第K个，返回指针 */</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">/* 没找到第K个，循环因为 p=NULL 而退出 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>按值查找：Find(ElementType x, List L)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List <span class="title function_">Find</span><span class="params">( ElementType X, List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">   List p = PtrL;</span><br><span class="line">   <span class="keyword">while</span> ( p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;Data != X ) <span class="comment">// 条件1表不空，条件2没找到X，就继续</span></span><br><span class="line">      p = p-&gt;Next;</span><br><span class="line">   <span class="keyword">return</span> p; <span class="comment">//找到了：返回节点p。没找到返回p = NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入<br>
在第 i-1 (1≤i≤n+1) 个结点后插入一个值为X的新结点</li>
</ul>
<ol>
<li>先构造一个新结点，用s指向; mallo</li>
<li>再找到链表的第 i-1个结点，用p指向;</li>
<li>然后修改指针，插入结点 ( p之后插入新结点是 s)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s-&gt; next = p -&gt; next;</span><br><span class="line">p -&gt; next = s</span><br></pre></td></tr></table></figure>
<p>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List <span class="title function_">Insert</span><span class="params">( ElementType X, <span class="type">int</span> i, List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">   List p, s; </span><br><span class="line">   <span class="keyword">if</span> ( i == <span class="number">1</span> )   <span class="comment">/* 新结点插入在表头 */</span></span><br><span class="line">   &#123;</span><br><span class="line">      s = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));  <span class="comment">/*申请、填装结点s */</span></span><br><span class="line">      s-&gt;Data = X;</span><br><span class="line">      s-&gt;Next = PtrL; </span><br><span class="line">      <span class="keyword">return</span> s;  <span class="comment">// s成为新的head，返回出去</span></span><br><span class="line">   &#125;</span><br><span class="line">   p = FindKth( i<span class="number">-1</span>, PtrL );  <span class="comment">/* 查找第i-1个结点 */</span></span><br><span class="line">   <span class="keyword">if</span> ( p == <span class="literal">NULL</span> )  </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;参数i错&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">   &#123;</span><br><span class="line">      s = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode)); <span class="comment">/*申请、填装结点*/</span> </span><br><span class="line">      s-&gt;Data = X;</span><br><span class="line">      s-&gt;Next = p-&gt;Next; <span class="comment">/*新结点插入在第i-1个结点的后面*/</span> </span><br><span class="line">      p-&gt;Next = s;</span><br><span class="line">      <span class="keyword">return</span> PtrL;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除<br>
删除链表的第 i (1≤i≤n) 个位置上的节点</li>
</ul>
<ol>
<li>先找到链表的第 i-1个结点，用p指向;</li>
<li>再用指针s指向要被删除的结点(p的下一个结点);</li>
<li>然后修改指针，删除s所指结点;  <code>p-&gt;next = s-&gt;next</code></li>
<li>最后释放s所指结点的空间。<br>
实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List <span class="title function_">Delete</span><span class="params">( <span class="type">int</span> i, List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">   List p, s;</span><br><span class="line">   <span class="keyword">if</span> ( i == <span class="number">1</span> ) </span><br><span class="line">   &#123; <span class="comment">/* 若要删除的是表的第一个结点 */</span></span><br><span class="line">      s = PtrL; <span class="comment">/*s指向第1个结点*/</span> </span><br><span class="line">      <span class="keyword">if</span> (PtrL!=<span class="literal">NULL</span>) </span><br><span class="line">         PtrL = PtrL-&gt;Next; <span class="comment">/*从链表中删除*/</span></span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 如果本身就是空链表，return NULL</span></span><br><span class="line">      <span class="built_in">free</span>(s);</span><br><span class="line">      <span class="keyword">return</span> PtrL;</span><br><span class="line">   &#125;</span><br><span class="line">   p = FindKth( i<span class="number">-1</span>, PtrL ); <span class="comment">/*查找第i-1个结点*/</span>   </span><br><span class="line">   <span class="keyword">if</span> ( p == <span class="literal">NULL</span> ) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(“第%d个结点不存在”, i<span class="number">-1</span>); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> ( p-&gt;Next == <span class="literal">NULL</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(“第%d个结点不存在”, i); </span><br><span class="line">   &#125;<span class="keyword">else</span> </span><br><span class="line">   &#123;</span><br><span class="line">      s = p-&gt;Next;   <span class="comment">/*s指向第i个结点*/</span></span><br><span class="line">      p-&gt;Next = s-&gt;Next;   <span class="comment">/*从链表中删除*/</span></span><br><span class="line">      <span class="built_in">free</span>(s);  <span class="comment">/*释放被删除结点 */</span></span><br><span class="line">      <span class="keyword">return</span> PtrL;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>广义表  Generalized List</h1>
<p>二元多项式<br>
可以将上述二元多项式看成关于x 的一元多项式<br>
矩阵可以用二维数组表示，但二维数组表示有两个缺陷：</p>
<ol>
<li>一是数组的大小需要事先确定</li>
<li>对于“稀疏矩阵 ”，将造成大量的存储空间浪费。<br>
采用一种典型的多重链表——十字链表来存储稀疏矩阵</li>
</ol>
<ul>
<li>只存储矩阵非0元素项 结点的数据域:行坐标Row、列坐标Col、数值Value</li>
<li>每个结点通过两个指针域，把同行、同列串起来
<ul>
<li>行指针(或称为向右指针)Right</li>
<li>列指针(或称为向下指针)Down</li>
</ul>
</li>
</ul>
<p>Term 代表非0项<br>
特殊Term A 代表4行5列，7个非零项</p>
<h1>堆栈 Stack</h1>
<p>具有一定操作约束的线性表，只在一端(栈顶，Top)做 插入、删除<br>
操作集:长度为MaxSize的堆栈S 属于 Stack，堆栈元素item 属于 ElementType</p>
<ol>
<li>Stack CreateStack( int MaxSize ): 生成空堆栈，其最大长度为MaxSize;</li>
<li>int IsFull( Stack S, int MaxSize ):判断堆栈S是否已满;</li>
<li>void Push( Stack S, ElementType item ):将元素item压入堆栈;</li>
<li>int IsEmpty ( Stack S ):判断堆栈S是否为空;</li>
<li>ElementType Pop( Stack S ):删除并返回栈顶元素;</li>
</ol>
<h2 id="栈的顺序存储实现">栈的顺序存储实现</h2>
<p>栈的顺序存储结构通常由一个一维数组和一个记录.栈顶元素位置的变量组成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize <span class="string">&lt;储存数据元素的最大个数&gt;</span> </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span>  <span class="comment">//结构指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];  <span class="comment">//数组</span></span><br><span class="line">    <span class="type">int</span> Top; <span class="comment">// 栈顶位置的数组下标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>入栈 Push</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">( Stack PtrS, ElementType item )</span>  <span class="comment">// stack这个类型的指针</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( PtrS-&gt;Top == MaxSize<span class="number">-1</span> ) <span class="comment">// 判断满不满。从 0 到 MaxSize-1</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(“堆栈满”); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        PtrS-&gt;Data[++(PtrS-&gt;Top)] = item; </span><br><span class="line">        <span class="comment">/* 相当于：</span></span><br><span class="line"><span class="comment">        (PtrS-&gt;Top)++;</span></span><br><span class="line"><span class="comment">        PtrS-&gt;Data[PtrS-&gt;Top] = item;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>出栈 Top</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">Pop</span><span class="params">( Stack PtrS )</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( PtrS-&gt;Top == <span class="number">-1</span> ) </span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">printf</span>(“堆栈空”);</span><br><span class="line">         <span class="keyword">return</span> ERROR;  <span class="comment">//ERROR是ElementType的特殊值，标志错误</span></span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ( PtrS-&gt;Data[(PtrS-&gt;Top)--] ); <span class="comment">// return 出下标为top的这个值，同时Top-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[例] 请用一个数组实现两个堆栈，要求最大地利用数组空间，使 数组只要有空间入栈操作就可以成功。<br>
【分析】 一种比较聪明的方法是使这两个栈分别从数组的两头开始 向中间生长;当两个栈的栈顶指针相遇时，表示两个栈都满了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize <span class="string">&lt;存储数据元素的最大个数&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DStack</span> &#123;</span></span><br><span class="line">    ElementType Data[MaxSize]; </span><br><span class="line">    <span class="type">int</span> Top1; <span class="comment">/* 堆栈1的栈顶指针 */</span> </span><br><span class="line">    <span class="type">int</span> Top2; <span class="comment">/* 堆栈2的栈顶指针 */</span></span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line">S.Top1 = <span class="number">-1</span>; <span class="comment">// 左边这个设为空</span></span><br><span class="line">S.Top2 = MaxSize; <span class="comment">// 右边设为空（已经超出了MaxSize -1)</span></span><br></pre></td></tr></table></figure>
<p>入栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">( <span class="keyword">struct</span> DStack *PtrS, ElementType item, <span class="type">int</span> Tag )</span> </span><br><span class="line">&#123; <span class="comment">/* Tag作为区分两个堆栈的标志，取值为1和2 */</span></span><br><span class="line">    <span class="keyword">if</span> ( PtrS-&gt;Top2 – PtrS-&gt;Top1 == <span class="number">1</span>) <span class="comment">/* 堆栈满, 两个指针相邻啦 */</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(“堆栈满”); </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( Tag == <span class="number">1</span> ) <span class="comment">/* 对第一个堆栈操作 */</span></span><br><span class="line">        PtrS-&gt;Data[++(PtrS-&gt;Top1)] = item;  <span class="comment">// 放在第一个元素后面一位</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 对第二个堆栈操作 */</span> </span><br><span class="line">        PtrS-&gt;Data[--(PtrS-&gt;Top2)] = item;  <span class="comment">// 放在最后一个元素的前面一位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">Pop</span><span class="params">( <span class="keyword">struct</span> DStack *PtrS, <span class="type">int</span> Tag )</span> </span><br><span class="line">&#123; <span class="comment">/* Tag区分两个堆栈*/</span></span><br><span class="line">    <span class="keyword">if</span>(Tag==<span class="number">1</span>) <span class="comment">/*对第一个堆栈操作 */</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> ( PtrS-&gt;Top1 == <span class="number">-1</span> )  <span class="comment">/*堆栈1空 */</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="built_in">printf</span>(“堆栈<span class="number">1</span>空”); </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> PtrS-&gt;Data[(PtrS-&gt;Top1)--]; <span class="comment">// 先抛出再对top-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="comment">/* 对第二个堆栈操作 */</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> ( PtrS-&gt;Top2 == MaxSize )  <span class="comment">/*堆栈2空 */</span></span><br><span class="line">        &#123;        </span><br><span class="line">            <span class="built_in">printf</span>(“堆栈<span class="number">2</span>空”); </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> PtrS-&gt;Data[(PtrS-&gt;Top2)++]; <span class="comment">// 先抛出再对top+1</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆栈的链式存储实">堆栈的链式存储实</h2>
<p>栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删 除操作只能在链栈的栈顶进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Next</span>;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化(建立空栈)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack <span class="title function_">CreateStack</span><span class="params">()</span></span><br><span class="line">&#123; <span class="comment">/* 构建一个堆栈的头结点，返回指针 */</span></span><br><span class="line">    Stack S;</span><br><span class="line">    S =(Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> SNode)); </span><br><span class="line">    S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断堆栈S是否为空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(Stack S)</span> <span class="comment">/*判断堆栈S是否为空，若为空函数返回1，否则返回0 */</span></span><br><span class="line">&#123; </span><br><span class="line">   <span class="keyword">return</span> ( S-&gt;Next == <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>入栈 Push</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">( ElementType item, Stack S)</span> <span class="comment">/* 将元素item压入堆栈S */</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">TmpCell</span>;</span></span><br><span class="line">    TmpCell=(<span class="keyword">struct</span> SNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> SNode))</span><br><span class="line">    TmpCell-&gt;Element = item;</span><br><span class="line">    TmpCell-&gt;Next = S-&gt;Next;  <span class="comment">// 插到头结点的后面</span></span><br><span class="line">    S-&gt;Next = TmpCell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>出栈 Top</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">Pop</span><span class="params">(Stack S)</span>  <span class="comment">/* 删除并返回堆栈S的栈顶元素 */</span></span><br><span class="line">&#123; </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">FirstCell</span>;</span></span><br><span class="line">   ElementType TopElem;</span><br><span class="line">   <span class="keyword">if</span>( IsEmpty( S ) ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“堆栈空”); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        FirstCell = S-&gt;Next;</span><br><span class="line">        S-&gt;Next = FirstCell-&gt;Next; </span><br><span class="line">        TopElem = FirstCell -&gt;Element; <span class="comment">// 获得被删除的这个值,return出去</span></span><br><span class="line">        <span class="built_in">free</span>(FirstCell);</span><br><span class="line">        <span class="keyword">return</span> TopElem;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用-表达式求值">应用:表达式求值</h2>
<ol>
<li>
<p>运算数相对顺序不变</p>
</li>
<li>
<p>运算符号顺序发生改变: 需要存储“等待中”的运算符号,要将当前运算符号与“等待中”的最后一个运算符号比较</p>
<p>如果最后一个符号的优先级比较高,则出栈</p>
<p>如果最后一个符号的优先级更低,则等待</p>
</li>
</ol>
<p>括号怎么办?<br>
左括号(优先级比乘号*高.但左括号(在堆栈中优先级就降到最低, 左括号(优先级比加号+低.<br>
碰到右括号)后,括号内的计算结束,把堆栈内的抛出来,直到遇到左括号(.</p>
<h1>队列 Queue</h1>
<p>FIFO<br>
操作集:长度为MaxSize的队列Q Î Queue，队列元素item Î ElementType</p>
<ol>
<li>Queue CreatQueue( int MaxSize ):生成长度为MaxSize的空队列;</li>
<li>int IsFullQ( Queue Q, int MaxSize ):判断队列Q是否已满;</li>
<li>void AddQ( Queue Q, ElementType item ): 将数据元素item插入队列Q中;</li>
<li>int IsEmptyQ( Queue Q ): 判断队列Q是否为空;</li>
<li>ElementType DeleteQ( Queue Q ):将队头数据元素从队列中删除并返回。</li>
</ol>
<h2 id="队列的顺序存储实现">队列的顺序存储实现</h2>
<p>一个一维数组,队列头元素位置的变量front, 队列为元素位置的变量rear, 而堆栈由一个一位数组加上一个top.<br>
队列的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize <span class="string">&lt;储存数据元素的最大个数&gt;</span> </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    ElementType Data[ MaxSize ]; </span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br></pre></td></tr></table></figure>
<p>循环队列<br>
当front == rear时候, 空<br>
rear指向这个队列实际的最后一个元素的位置,front是第一个元素的前一个. 加入一个元素的时候rear + 1, 删除一个元素的时候front + 1<br>
使用额外标记 size或者tag<br>
仅使用n-1个数组空间</p>
<ol>
<li>创建队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Queue <span class="title function_">CreateQueue</span><span class="params">(<span class="type">int</span> Maxsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">    Q-&gt;Data = (ElementType)<span class="built_in">malloc</span>(Maxsize * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;Maxsize = Maxsize;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>入队列<br>
用求余数函数,实现循环队列 例如 (5+1)%6 = 0, 放在第0位</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AddQ</span><span class="params">( Queue PtrQ, ElementType item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (PtrQ-&gt;rear+<span class="number">1</span>) % MaxSize == PtrQ-&gt;front ) <span class="comment">// front rear相邻</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(“队列满”);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PtrQ-&gt;rear = (PtrQ-&gt;rear+<span class="number">1</span>)% MaxSize; </span><br><span class="line">    PtrQ-&gt;Data[PtrQ-&gt;rear] = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>出队</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">DeleteQ</span> <span class="params">( Queue PtrQ )</span> <span class="comment">// front和rear相同</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( PtrQ-&gt;front == PtrQ-&gt;rear ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(“队列空”);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        PtrQ-&gt;front = (PtrQ-&gt;front+<span class="number">1</span>)% MaxSize; <span class="comment">// front往后移一位指向第一个元素</span></span><br><span class="line">        <span class="keyword">return</span> PtrQ-&gt;Data[PtrQ-&gt;front];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列的链式存储实现">队列的链式存储实现</h2>
<p>链表结点结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> </span><br><span class="line">    ElementType Data; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>链表队列结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">rear</span>;</span> <span class="comment">/* 指向队尾结点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">front</span>;</span> <span class="comment">/* 指向队头结点 */</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span>  </span><br><span class="line">Queue PtrQ;  <span class="comment">// 包含front和rear的这个结构的指针PtrQ</span></span><br></pre></td></tr></table></figure>
<ol>
<li>出队</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">DeleteQ</span> <span class="params">( Queue PtrQ )</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">FrontCell</span>;</span></span><br><span class="line">    ElementType FrontElem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( PtrQ-&gt;front == <span class="literal">NULL</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(“队列空”); </span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    FrontCell = PtrQ-&gt;front;  <span class="comment">// 找到队列的头个元素</span></span><br><span class="line">    <span class="keyword">if</span> ( PtrQ-&gt;front == PtrQ-&gt;rear) <span class="comment">/* 若队列只有一个元素 */</span></span><br><span class="line">        PtrQ-&gt;front = PtrQ-&gt;rear = <span class="literal">NULL</span>; <span class="comment">/* 删除后队列置为空 */</span> </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PtrQ-&gt;front = PtrQ-&gt;front-&gt;Next;</span><br><span class="line">    FrontElem = FrontCell-&gt;Data;</span><br><span class="line">    <span class="built_in">free</span>( FrontCell ); <span class="comment">/* 释放被删除结点空间 */</span> </span><br><span class="line">    <span class="keyword">return</span> FrontElem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用-多项式加法运算">应用: 多项式加法运算</h2>
<p>算法思路:<br>
两个指针P1和P2分别指向这两个多项式第一个结点，不断循环:</p>
<ol>
<li>P1-&gt;expon==P2-&gt;expon相同: 系数相加，若结果不为0，则作为结果多项式对应项<br>
的系数。同时，P1和P2都分别指向下一项;</li>
<li>P1-&gt;expon&gt;P2-&gt;expon 这时p1大: 将P1的当前项存入结果多项式，并使P1指向下一项;</li>
<li>P1-&gt;expon<P2->expon 这时p2大: 将P2的当前项存入结果多项式，并使P2指向下一项;</li>
<li>当某一多项式处理完时，将另一个多项式的所有结点依次复制到结果多项式中去。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> //结构类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> coef; <span class="comment">// 系数</span></span><br><span class="line">    <span class="type">int</span> expon; <span class="comment">// 指数 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">link</span>;</span>  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynomial</span>;</span> </span><br><span class="line">Polynomial P1, P2;  <span class="comment">// p1 p2都是这种结构的指针</span></span><br></pre></td></tr></table></figure>
<p>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Polynomial <span class="title function_">PolyAdd</span> <span class="params">(Polynomial P1, Polynomial P2)</span> </span><br><span class="line">&#123;</span><br><span class="line">    Polynomial front, rear, temp;  <span class="comment">// 结构多项式的头 尾.</span></span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 临时空结点点作为结果多项式的表头, front rear都指向这个空间点</span></span><br><span class="line">    rear = (Polynomial) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PolyNode)); </span><br><span class="line">    front = rear; <span class="comment">/* 由front 记录结果多项式链表头结点 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( P1 &amp;&amp; P2 ) <span class="comment">/* 当两个多项式都有非零项(都不空)待处理时 */</span> </span><br><span class="line">        <span class="keyword">switch</span> ( Compare(P1-&gt;expon, P2-&gt;expon) ) <span class="comment">// 比较两个指数</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">// p1大</span></span><br><span class="line">                <span class="comment">// 系数和指素接到rear的后面</span></span><br><span class="line">                Attach( P1-&gt;coef, P1-&gt;expon, &amp;rear); </span><br><span class="line">                P1 = P1-&gt;link;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">// p2大</span></span><br><span class="line">                Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear); </span><br><span class="line">                P2 = P2-&gt;link;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//p1 = p2</span></span><br><span class="line">                sum = P1-&gt;coef + P2-&gt;coef;</span><br><span class="line">                <span class="comment">// 判断sum不等于0</span></span><br><span class="line">                <span class="keyword">if</span> ( sum ) Attach(sum, P1-&gt;expon, &amp;rear); </span><br><span class="line">                P1 = P1-&gt;link;</span><br><span class="line">                P2 = P2-&gt;link;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/* 将未处理完的另一个多项式的所有节点依次复制到结果多项式中去 */</span> </span><br><span class="line">    <span class="comment">// p1不空</span></span><br><span class="line">    <span class="keyword">for</span> ( ; P1; P1 = P1-&gt;link ) </span><br><span class="line">        Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">    <span class="comment">// p2 不空</span></span><br><span class="line">    <span class="keyword">for</span> ( ; P2; P2 = P2-&gt;link ) </span><br><span class="line">        Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rear 指向结果多项式的最后一项,现在结束了,把link设为NULL</span></span><br><span class="line">    rear-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 释放临时结点</span></span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;link; <span class="comment">/*令front指向结果多项式第一个非零项 */</span> </span><br><span class="line">    <span class="built_in">free</span>(temp); <span class="comment">/* 释放临时空表头结点 */</span></span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中attach函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入系数和指数,以及最后一个结点的指针位置(指针的指针),于在本函数中需要改变当前结果表达式尾项指针的值,所以函数传递进来的是结点指针的地址，*pRear指向尾项</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">Attach</span><span class="params">( <span class="type">int</span> c, <span class="type">int</span> e, Polynomial *pRear )</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynomial P;</span><br><span class="line">    <span class="comment">/* 申请新结点 */</span> </span><br><span class="line">    P =(Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PolyNode)); </span><br><span class="line">    P-&gt;coef = c; <span class="comment">/* 对新结点赋值 */</span></span><br><span class="line">    P-&gt;expon = e;</span><br><span class="line">    P-&gt;link=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* 将P指向的新结点插入到当前结果表达式尾项的后面 */</span> </span><br><span class="line">    (*pRear)-&gt;link = P;</span><br><span class="line">    *pRear = P; <span class="comment">/* 修改pRear值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>树与树的表示</h1>
<p>查找 Searching</p>
<ul>
<li>静态查找 集合是固定的,没有插入和删除</li>
<li>动态查找 集合中的记录是动态变化的,可以插入和删除</li>
</ul>
<h3 id="静态查找-Sequential-Search">静态查找 Sequential Search</h3>
<p>结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>&#123;</span></span><br><span class="line">    ElementType Element[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SequentialSearch</span><span class="params">(List tb1, ElementType K)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    tb1-&gt;Element[<span class="number">0</span>] = K; <span class="comment">// 建立哨兵</span></span><br><span class="line">    <span class="keyword">for</span>(i = tb1-&gt;length; tb1-&gt;Element[i] != K; i--); <span class="comment">//从下往上循环直到K</span></span><br><span class="line">    <span class="keyword">return</span> i;  <span class="comment">// 成功返回下标,不成功返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序查找算法的时间复杂度为O(n)</p>
<h3 id="二分查找-Binary-Search">二分查找 Binary Search</h3>
<p>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BinarySearch</span> <span class="params">( StaticTable * Tb1, ElementType K)</span> </span><br><span class="line">&#123; <span class="comment">/*在表Tbl中查找关键字为K的数据元素*/</span></span><br><span class="line">    <span class="type">int</span> left, right, mid, NoFound=<span class="number">-1</span>;</span><br><span class="line">    left = <span class="number">1</span>;</span><br><span class="line">    right = Tb1-&gt;Length; </span><br><span class="line">    <span class="keyword">while</span> ( left &lt;= right ) </span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( K &lt; Tb1-&gt;Element[mid]) right = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( K &gt; Tb1-&gt;Element[mid]) left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid; <span class="comment">/*查找成功，返回数据元素的下标*/</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> NotFound; <span class="comment">/*查找不成功，返回-1*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二分查找算法具有对数的时间复杂度O(logN)<br>
判定树:<br>
判定树上每个结点需要的查找次数刚好 为该结点所在的层数.<br>
n个结点的判定树的深度 为[log2n]+1.</p>
<h2 id="树-Tree">树 Tree</h2>
<p>定义:n(n≥0)个结点构成的有限集合<br>
子树是不相交的,除了根结点外，每个结点有且仅有一个父结点<br>
结点的度(Degree):结点的子树个数<br>
树的度:树的所有结点中最大的度数<br>
结点的层次(Level):规定根结点在1层， 其它任一结点的层数是其父结点的层数加1。<br>
树的深度(Depth):树中所有结点中的最 大层次是这棵树的深度。</p>
<h3 id="二叉树">二叉树</h3>
<p>度为2的树,可以为空.若不为空由根节点和左子树和右子树</p>
<ul>
<li>一个二叉树第 i 层的最大结点数为:2^(i-1)</li>
<li>深度为k的二叉树有最大结点总数为: 2^k -1</li>
<li>对任何非空二叉树T，若$n_0$表示叶结点的个数、$n_2$是度为2的非叶结点个数，那么两者满足关系$n_0 = n_2 +1$<br>
证明: 总边数=总节点数-1 (因为根没有向上的边)<br>
总边数= n0 + n1 +n2 -1<br>
总边数 = 0<em>n0 + 1</em>n1 + 2*n2  (往下看)</li>
</ul>
<p>二叉树的存储结构</p>
<ol>
<li>顺序存储结构<br>
完全二叉树<br>
父节点:i/2<br>
左子节点: 2i<br>
右子节点: 2i+1</li>
<li>链表存储</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">BinTree</span>;</span> </span><br><span class="line"><span class="keyword">typedef</span> BinTree Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data; </span><br><span class="line">    BinTree Left; </span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的遍历">二叉树的遍历</h3>
<ol start="2">
<li>先序遍历  PreOrder Traversal<br>
根节点-&gt;左子树-&gt;右子树</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">PreOrderTraversal</span><span class="params">( BinTree BT )</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>( BT ) <span class="comment">// BT不空</span></span><br><span class="line">     &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“%d”, BT-&gt;Data);</span><br><span class="line">        PreOrderTraversal( BT-&gt;Left );</span><br><span class="line">        PreOrderTraversal( BT-&gt;Right );</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>中序遍历 InOrderT Traversal<br>
左子树-&gt;根节点-&gt;右子树</li>
<li>后序遍历 Post-Order Traversal<br>
左子树-&gt;右子树-&gt;根节点</li>
</ol>
<p>二叉树的非递归遍历<br>
中序遍历的非递归算法实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraversal</span><span class="params">( BinTree BT )</span></span><br><span class="line">&#123;  </span><br><span class="line">    BinTree T=BT;</span><br><span class="line">    Stack S = CreatStack( MaxSize ); <span class="comment">/*创建并初始化堆栈S*/</span> </span><br><span class="line">    <span class="keyword">while</span>( T || !IsEmpty(S) )</span><br><span class="line">    &#123;  <span class="comment">//IsEmpty是判断堆栈空不空</span></span><br><span class="line">        <span class="keyword">while</span>(T)&#123; <span class="comment">/*一直向左并将沿途结点压入堆栈*/</span> \</span><br><span class="line">            Push(S,T);</span><br><span class="line">            T = T-&gt;Left; </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))&#123;</span><br><span class="line">            T = Pop(S); <span class="comment">/*结点弹出堆栈*/</span></span><br><span class="line">            <span class="built_in">printf</span>(“%<span class="number">5</span>d”, T-&gt;Data); <span class="comment">/*(访问)打印结点*/</span> </span><br><span class="line">            T = T-&gt;Right; <span class="comment">/*转向右子树*/</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历">层序遍历</h3>
<p>队列实现:遍历从根结点开始，首先将根结点入队，然后开始执 行循环:结点出队、访问该结点、其左右儿子入队<br>
算法实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrderTraversal</span> <span class="params">( BinTree BT )</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue Q; BinTree T;</span><br><span class="line">    <span class="keyword">if</span> ( !BT ) <span class="keyword">return</span>; <span class="comment">/* 若是空树则直接返回 */</span> </span><br><span class="line">    Q = CreatQueue( MaxSize ); <span class="comment">/*创建并初始化队列Q*/</span> </span><br><span class="line">    AddQ( Q, BT ); <span class="comment">// 把根节点放到队列里去</span></span><br><span class="line">    <span class="keyword">while</span> ( !IsEmptyQ( Q ) ) &#123;</span><br><span class="line">        T = DeleteQ( Q );  <span class="comment">// pop出一个元素,产生的元素赋给 T指针</span></span><br><span class="line">        <span class="built_in">printf</span>(“%d\n”, T-&gt;Data); <span class="comment">/*访问取出队列的结点*/</span> </span><br><span class="line">        <span class="keyword">if</span> ( T-&gt;Left ) AddQ( Q, T-&gt;Left );</span><br><span class="line">        <span class="keyword">if</span> ( T-&gt;Right ) AddQ( Q, T-&gt;Right );</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出二叉树叶子节点">输出二叉树叶子节点</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrderPrintLeaves</span><span class="params">( BinTree BT )</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( BT ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !BT-&gt;Left &amp;&amp; !BT-&gt;Right ) <span class="comment">// 如果没有左右子树,就打印出来</span></span><br><span class="line">            <span class="built_in">printf</span>(“%d”, BT-&gt;Data ); </span><br><span class="line">        PreOrderPrintLeaves ( BT-&gt;Left ); </span><br><span class="line">        PreOrderPrintLeaves ( BT-&gt;Right );</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求二叉树的高度">求二叉树的高度</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PostOrderGetHeight</span><span class="params">( BinTree BT )</span> </span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> HL, HR, MaxH;</span><br><span class="line">    <span class="keyword">if</span>( BT ) </span><br><span class="line">    &#123;</span><br><span class="line">        HL = PostOrderGetHeight(BT-&gt;Left); <span class="comment">/*求左子树的深度*/</span> </span><br><span class="line">        HR = PostOrderGetHeight(BT-&gt;Right); <span class="comment">/*求右子树的深度*/</span> </span><br><span class="line">        MaxH = (HL &gt; HR)? HL : HR; <span class="comment">/*取左右子树较大的深度*/</span> </span><br><span class="line">        <span class="keyword">return</span> ( MaxH + <span class="number">1</span> ); <span class="comment">/*返回树的深度*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 空树深度为0 */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层序生成二叉树">层序生成二叉树</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType; <span class="comment">//假设是int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NoInfo 0;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">BinTree</span>;</span> </span><br><span class="line"><span class="keyword">typedef</span> BinTree Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data; </span><br><span class="line">    BinTree Left; </span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree <span class="title function_">CreateBinTree</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree BT, T;</span><br><span class="line">    Q = CreateQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入第一个检点,即根节点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Data);</span><br><span class="line">    <span class="keyword">if</span> (Data != NoInfo)</span><br><span class="line">    &#123; <span class="comment">// 不为空, 分配根节点单元,并将节点地址入队</span></span><br><span class="line">        BT = (BinTree)mallo(<span class="keyword">sizeof</span>(Struct Tnode));</span><br><span class="line">        BT-&gt;Data = Data;</span><br><span class="line">        Bt-&gt;Left = BT-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">        AddQ(Q, BT);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//若第一个数据0,则返回空树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        T-&gt;DeleteQ(Q);  <span class="comment">//从队列中取出一节点地址</span></span><br><span class="line">        <span class="comment">// 读左孩子</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Data);</span><br><span class="line">        <span class="keyword">if</span>(Data != NoInfo)</span><br><span class="line">            T-&gt;Left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 分配新节点,作为出队节点的左孩子,分配的新节点入队</span></span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;Left = (BinTree)mallo(<span class="keyword">sizeof</span>(Struct Tnode));</span><br><span class="line">            T-&gt;Left-&gt;Data = Data;</span><br><span class="line">            T-&gt;Left-&gt;Left = T-&gt;Left-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">            AddQ(Q, T-&gt;Left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读右孩子</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Data);</span><br><span class="line">        <span class="keyword">if</span>(Data != NoInfo)</span><br><span class="line">            T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 分配新节点,作为出队节点的右孩子,分配的新节点入队</span></span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;Right = (BinTree)mallo(<span class="keyword">sizeof</span>(Struct Tnode));</span><br><span class="line">            T-&gt;Right-&gt;Data = Data;</span><br><span class="line">            T-&gt;Right-&gt;Left = T-&gt;Right-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">            AddQ(Q, T-&gt;Left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// while循环结束</span></span><br><span class="line">    <span class="keyword">return</span> BT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>二叉搜索树 Binary Search Tree</h1>
<ol>
<li>非空左子树所有键值小于根节点的键值</li>
<li>非空右子树所有键值大于根节点的键值</li>
<li>左右子树都是二叉搜索树</li>
</ol>
<p>操作的函数:</p>
<ol>
<li>Position Find( ElementType X, BinTree BST ):从二叉搜索树BST 中查找元素X，返回其所在结点的地址;</li>
<li>Position FindMin( BinTree BST ):从二叉搜索树BST中查找并返回 最小元素所在结点的地址;</li>
<li>Position FindMax( BinTree BST ) :从二叉搜索树BST中查找并返回 最大元素所在结点的地址。</li>
<li>BinTree Insert( ElementType X, BinTree BST ) 插入</li>
<li>BinTree Delete( ElementType X, BinTree BST ) 删除</li>
</ol>
<h2 id="查找">查找</h2>
<p>递归实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">Find</span><span class="params">( ElementType X, BinTree BST )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( !BST ) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/*查找失败*/</span> </span><br><span class="line">    <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">        <span class="keyword">return</span> Find( X, BST-&gt;Right ); <span class="comment">/*在右子树中继续查找*/</span></span><br><span class="line">    Else <span class="title function_">if</span><span class="params">( X &lt; BST-&gt;Data )</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">Find</span><span class="params">( X, BST-&gt;Left )</span>; <span class="comment">/*在左子树中继续查找*/</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">/* X == BST-&gt;Data */</span></span><br><span class="line">        <span class="keyword">return</span> BST; <span class="comment">/*查找成功，返回结点的找到结点的地址*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">IterFind</span><span class="params">( ElementType X, BinTree BST )</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>( BST ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">            BST = BST-&gt;Right; <span class="comment">/*向右子树中移动，继续查找*/</span> </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">            BST = BST-&gt;Left; <span class="comment">/*向左子树中移动，继续查找*/</span> </span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* X == BST-&gt;Data */</span></span><br><span class="line">            <span class="keyword">return</span> BST; <span class="comment">/*查找成功，返回结点的找到结点的地址*/</span> </span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/*查找失败*/</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="返回最大值-最小值">返回最大值/最小值</h2>
<p>最大元素一定在最右分支的端点上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">FindMax</span><span class="params">( BinTree BST )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST ) <span class="comment">// 结点不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( BST-&gt;Right ) <span class="comment">// 右儿子不空</span></span><br><span class="line">            BST = BST-&gt;Right; <span class="comment">// 则往右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最小元素在最左段上<br>
递归法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Position <span class="title function_">FindMin</span><span class="params">( BinTree BST )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( !BST ) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">/*空的二叉搜索树，返回NULL*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( !BST-&gt;Left )</span><br><span class="line">        <span class="keyword">return</span> BST; <span class="comment">/*找到最左叶结点并返回*/</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> FindMin( BST-&gt;Left ); <span class="comment">/*沿左分支继续查找*/</span></span><br></pre></td></tr></table></figure>
<h2 id="插入">插入</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">Insert</span><span class="params">( ElementType X, BinTree BST )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( !BST ) <span class="comment">/*若原树为空，生成并返回一个结点的二叉搜索树*/</span></span><br><span class="line">    &#123; </span><br><span class="line">        BST = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode)); </span><br><span class="line">        BST-&gt;Data = X;            </span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/*开始找要插入元素的位置*/</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Left = Insert( X, BST-&gt;Left); <span class="comment">/*递归插入左子树*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Right = Insert( X, BST-&gt;Right); <span class="comment">/*递归插入右子树*/</span></span><br><span class="line">    <span class="comment">/* else X已经存在，什么都不做 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除">删除</h2>
<ol start="2">
<li>
<p>删除的是叶结点</p>
</li>
<li>
<p>删除的只有一个孩子的结点</p>
</li>
<li>
<p>要删除的结点右左右两棵子树,则:</p>
<p>右子树最小元素替代</p>
<p>左子树最大元素替代</p>
</li>
</ol>
<p>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">Delete</span><span class="params">( BinTree BST, ElementType X )</span> </span><br><span class="line">&#123; </span><br><span class="line">    Position Tmp; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( !BST ) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到&quot;</span>); </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Left = Delete( BST-&gt;Left, X );   <span class="comment">/* 从左子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( X &gt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Right = Delete( BST-&gt;Right, X ); <span class="comment">/* 从右子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">/* BST就是要删除的结点 */</span></span><br><span class="line">            <span class="comment">/* 如果被删除结点有左右两个子结点 */</span> </span><br><span class="line">            <span class="keyword">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) &#123;</span><br><span class="line">                <span class="comment">/* 从右子树中找最小的元素填充删除结点 */</span></span><br><span class="line">                Tmp = FindMin( BST-&gt;Right );</span><br><span class="line">                BST-&gt;Data = Tmp-&gt;Data;</span><br><span class="line">                <span class="comment">/* 从右子树中删除最小元素 */</span></span><br><span class="line">                BST-&gt;Right = Delete( BST-&gt;Right, BST-&gt;Data );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">/* 被删除结点有一个或无子结点 */</span></span><br><span class="line">                Tmp = BST; </span><br><span class="line">                <span class="keyword">if</span>( !BST-&gt;Left )       <span class="comment">/* 只有右孩子或无子结点 */</span></span><br><span class="line">                    BST = BST-&gt;Right; </span><br><span class="line">                <span class="keyword">else</span>                   <span class="comment">/* 只有左孩子 */</span></span><br><span class="line">                    BST = BST-&gt;Left;</span><br><span class="line">                <span class="built_in">free</span>( Tmp );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>平衡二叉树  Balanced Binary Tree</h1>
<p>平均查找长度ASL<br>
平衡因子(Balance Factor，简称BF): BF(T) = hL-hR，<br>
|BF(T)| &lt;= 1<br>
平衡二叉树的高度<br>
n_h: 高度为h的平衡二叉树最少结点数<br>
n_h = n_h-1 + n_h-2 + 1<br>
= F_h+2 - 1<br>
给定结点数为 n的AVL树的 最大高度为O(log2n)!</p>
<h2 id="调整">调整</h2>
<p>平衡二叉树是搜索树<br>
右单旋<br>
麻烦结点在发现者(被破坏者)的右子树的右子树上,因而RR插入,需要RR旋转<br>
左单旋<br>
麻烦结点在发现者(被破坏者)的左子树的左子树上,因而LL旋转<br>
左右旋转<br>
麻烦结点在发现者(被破坏者)的左子树的右子树上, LR旋转</p>
<p>习题: 是否同一颗二叉搜索树</p>
<ol start="2">
<li>根据两个序列分别建树，再判别树是否一样</li>
<li>不建树的判别方法</li>
<li>建一棵树，再判别其他序列是否与该树一致</li>
</ol>
<h1>堆 Heap</h1>
<p>优先队列(Priority Queue)<br>
结构性:用 <em>数组</em> 表示的完全二叉树;<br>
有序性:任一结点的关键字是其子树所有结点的最大值(或最小值)<br>
* “最大堆(MaxHeap)”,也称“大顶堆”:最大值<br>
* “最小堆(MinHeap)”,也称“小顶堆” :最小值</p>
<p>主要操作有:<br>
• MaxHeap Create( int MaxSize ):创建一个空的最大堆。<br>
• Boolean IsFull( MaxHeap H ):判断最大堆H是否已满。<br>
• Insert( MaxHeap H, ElementType item ):将元素item插入最大堆H。<br>
• Boolean IsEmpty( MaxHeap H ):判断最大堆H是否为空。<br>
• ElementType DeleteMax( MaxHeap H ):返回H中最大元素(高优先级)。</p>
<h2 id="结构">结构</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HNode</span> *<span class="title">MaxHeap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HNode</span> &#123;</span></span><br><span class="line">    ElementType *Elements; <span class="comment">// 存储堆元素的数组</span></span><br><span class="line">    <span class="type">int</span> Size;   <span class="comment">// 堆的当前元素的个数</span></span><br><span class="line">    <span class="type">int</span> Capacity  <span class="comment">// 堆的最大容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建">创建</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MaxHeap <span class="title function_">CreateHeap</span><span class="params">(<span class="type">int</span> Maxsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    MaxHeap H = (MaxHeap)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HNode));</span><br><span class="line">    H-&gt;Elements = <span class="built_in">malloc</span>((MaxSize+<span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType)); <span class="comment">// 因为这里是一个数组,需要分配空间</span></span><br><span class="line">    H-&gt;Size = <span class="number">0</span>; <span class="comment">// 当前是空的</span></span><br><span class="line">    H-&gt;Capacity = MaxSize;  <span class="comment">// 堆的最大容量</span></span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MaxSize; <span class="comment">/* 定义“哨兵”为大于堆中所有可能元素的值，便于以后操作 */</span></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入-2">插入</h2>
<p>将新增结点插入到从其父结点到根结点的有序序列中<br>
将新item放在最后的位置Size+1, 然后跟他的父节点i/2比较,不断把父节点往下(子节点)移动,直到其父节点大于item</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertHeap</span><span class="params">(MaxHeap H, ElementType item)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (IsFull(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size;  <span class="comment">// H-&gt;Size++; i = H-&gt;Size; 把新增元素放在末尾H-&gt;Size++的位置上</span></span><br><span class="line">    <span class="keyword">for</span>(; H-&gt;Elements[i/<span class="number">2</span>] &lt; item; i/=<span class="number">2</span>)&#123;  <span class="comment">// 其父节点小于它</span></span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i/<span class="number">2</span>]; <span class="comment">// 把它的父节点,向下过滤, 插入的item向上过滤</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 当它的父结点[i/2]比它大的时候, 跳出循环</span></span><br><span class="line">    H-&gt;Elements[i] = item;  <span class="comment">// 填上item</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>删除</h1>
<p>取出根结点(最大值)元素，同时删除堆的一个结点。</p>
<ul>
<li>最后的元素替补根的位置</li>
<li>有序化, 父结点和更大的那个子结点比较,将子结点不断往上移, 直到父结点不子结点大</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">DeleteMax</span><span class="params">(MaxHeap H)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> parent, child;</span><br><span class="line">    ElementType MaxItem, temp;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MaxItem = H-&gt;Elements[<span class="number">1</span>]; <span class="comment">// 取出最大值</span></span><br><span class="line">    <span class="comment">/* 用最大堆中最后一个元素从根节点开始向上过滤下层节点 */</span></span><br><span class="line">    temp = H-&gt;Elements[Size];  <span class="comment">// 把堆中最后一个值,交给temp</span></span><br><span class="line">    Size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(parent=<span class="number">1</span>; parent*<span class="number">2</span> &lt;= H-&gt;Size; parent=child)</span><br><span class="line">    &#123;</span><br><span class="line">        child = parent*<span class="number">2</span>  <span class="comment">// 左儿子</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* child=左右儿子中大的那个, 当右儿子存在,且右儿子的值比左儿子大时,让child=右儿子 */</span></span><br><span class="line">        <span class="keyword">if</span>((child!= H-&gt;Size) &amp;&amp; </span><br><span class="line">        (H-&gt;Elements[child] &lt; H-&gt;Elements[child+<span class="number">1</span>])) </span><br><span class="line">            child++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 当temp比child的值大时跳出循环 */</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= Elements[child]) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child]; <span class="comment">//当parent &lt; child,这个parent位置上变为child的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp; </span><br><span class="line">    <span class="keyword">return</span> MaxItem; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>堆排序</h1>
<p>方法1:通过插入操作，将N个元素一个个相继插入到一个初 始为空的堆中去，其时间代价最大为O(N logN)。</p>
<p>方法2:在线性时间复杂度下建立最大堆。O(N)<br>
(1)将N个元素按输入顺序存入，先满足完全二叉树的结构特性<br>
(2)调整各结点位置，以满足最大堆的有序特性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BuildHeap</span><span class="params">(MaxHeap H)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = H-&gt;Size/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--) </span><br><span class="line">    &#123;<span class="comment">// 从最后一个结点的父节点开始,到根节点为止</span></span><br><span class="line">        PercDown(H, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下滤函数, 将Maxheap中以H-&gt;Data[p]为根的子堆调整为最大堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PercDown</span><span class="params">( MaxHeap H, <span class="type">int</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> parent, child;</span><br><span class="line"></span><br><span class="line">    X = H-&gt;Data[p]; <span class="comment">// 取出根节点的值</span></span><br><span class="line">    <span class="keyword">for</span>(parent =  p; parent*<span class="number">2</span> &lt;= H-&gt;Size; parent = child)</span><br><span class="line">    &#123;</span><br><span class="line">        child = parent * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( (child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child+<span class="number">1</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (X &gt; H-&gt;Data[child]) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 将X下滤</span></span><br><span class="line">            H-&gt;Data[parent] = H-&gt;Data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data(parent) = X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>哈夫曼树与哈夫曼编码</h1>
<p>带权路径WPL Weighted Path Length)长度最小, 最优二叉树.<br>
数据结构:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> Weight;</span><br><span class="line">    HaffmanTree left;</span><br><span class="line">    HaffmantREE Right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用最小堆进行构造:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HuffmanTree <span class="title function_">Huffman</span><span class="params">(MinHeap H)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    BuildMinHeap(H); <span class="comment">// 将H-&gt;Elements[]按照权重调整为最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i &lt; H-&gt;Size; i++) <span class="comment">// 做size-1次合并</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode)); <span class="comment">// 建立新结点</span></span><br><span class="line">        <span class="comment">/*从最小堆中删除一个结点，作为新T的左子结点*/</span></span><br><span class="line">        T-&gt;Left = DeleteMin(H);</span><br><span class="line">        T-&gt;Right = DeleteMin(H);</span><br><span class="line">        <span class="comment">/*计算新权值*/</span></span><br><span class="line">        T-&gt;Weight = T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight;</span><br><span class="line">        Insert( H, T ); <span class="comment">/*将新T插入最小堆*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    T = Deletemin(H); <span class="comment">// 最小堆中的最后一个元素就是指向Huffman树根节点的指针</span></span><br><span class="line">    <span class="keyword">return</span> T; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈夫曼树的特点:</p>
<ol>
<li>没有度为1的结点</li>
<li>n个叶子结点的哈夫曼树共有2n-1个结点;<br>
因为: n2= n0 -1,<br>
总结点数 = n0 + n2 = 2n0 - 1</li>
<li>哈夫曼树的任意非叶节点的左右子树交换后仍是哈夫曼树;</li>
<li>对同一组权值{w1 ,w2 , … , wn}，存在不同构的两</li>
</ol>
<h1>集合及运算</h1>
<p>双亲表示法: 孩子指向父节点<br>
数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    ElementType Data; </span><br><span class="line">    <span class="type">int</span> Parent;  <span class="comment">// 其父节点的下标</span></span><br><span class="line">&#125; SetType;</span><br></pre></td></tr></table></figure>
<h2 id="查找某个元素所在的集合">查找某个元素所在的集合</h2>
<p>用根节点表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(SetType S[], ElementType X)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 在数组S中查找值为X的元素所属的集合, MaxSize为数组最大长度 */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;MaxSize &amp;&amp; S[i].Data != X; i++)</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= MaxSize) <span class="comment">// 未找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; S[i].Parent &gt;= <span class="number">0</span>; i = s[i].Parent);  <span class="comment">// 向上找它的父节点</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合的并运算">集合的并运算</h2>
<p>如果它们不同根，则将其中一个根结点的父结点指针设置成<br>
另一个根结点的数组下标。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">( SetType S[], ElementType X1, ElementType X2 )</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Root1, Root2;</span><br><span class="line">    Root1 = Find(S, X1);</span><br><span class="line">    Root2 = Find(S, X2);</span><br><span class="line">    <span class="keyword">if</span>( Root1 != Root2 )</span><br><span class="line">        S[Root2].Parent = Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使树更矮,合并时按秩合并<br>
直接用一个数组表示,不用之前的数据结构了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000                  <span class="comment">/* 集合最大元素个数 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;           <span class="comment">/* 默认元素可以用非负整数表示 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SetName;               <span class="comment">/* 默认用根结点的下标作为集合名称 */</span></span><br><span class="line"><span class="keyword">typedef</span> ElementType SetType[MAXN]; <span class="comment">/* 假设集合元素下标从0开始 */</span></span><br><span class="line"></span><br><span class="line">SetName <span class="title function_">Find</span><span class="params">(SetType S, ElementType X)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; S[X] &gt; <span class="number">0</span>; X=S[X]);</span><br><span class="line">    <span class="keyword">return</span> X.</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> OldUnion(SetType S, SetName Root1, SetName Root2)&#123;</span><br><span class="line">    S[Root2] = Root1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">( SetType S, SetName Root1, SetName Root2 )</span></span><br><span class="line">&#123; <span class="comment">/* 这里默认Root1和Root2是不同集合的根结点 */</span></span><br><span class="line">    <span class="comment">/* 保证小集合并入大集合 */</span></span><br><span class="line">    <span class="keyword">if</span> ( S[Root2] &lt; S[Root1] ) &#123; <span class="comment">/* 如果集合2比较大 */</span></span><br><span class="line">        S[Root2] += S[Root1];     <span class="comment">/* 集合1并入集合2  */</span></span><br><span class="line">        S[Root1] = Root2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">/* 如果集合1比较大 */</span></span><br><span class="line">        S[Root1] += S[Root2];     <span class="comment">/* 集合2并入集合1  */</span></span><br><span class="line">        S[Root2] = Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路径压缩</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SetName <span class="title function_">Find</span><span class="params">( SetType S, ElementType X )</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> ( S[X] &lt; <span class="number">0</span> ) <span class="comment">/* 找到集合的根 */</span></span><br><span class="line">        <span class="keyword">return</span> X;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> S[X] = Find( S, S[X] ); <span class="comment">/* 路径压缩 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>图 Graph</h1>
<p>顶点的集合 V (Vertex)<br>
边的集合 E (Edge)</p>
<ul>
<li>邻接矩阵<br>
用一个长度为N(N+1)/2的1维数组A存储<br>
O(N^2)</li>
<li>邻接表<br>
G[N]为指针数组，对应矩阵每行一个链表， 只存非0元素<br>
O(N+E)</li>
</ul>
<h2 id="建立图">建立图</h2>
<p>邻接矩阵</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用全局变量建图</span></span><br><span class="line"><span class="type">int</span> G[MAXN][MAXN], Nv, Ne; </span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildGraph</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i,j,v1,v2,w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Nv);</span><br><span class="line">    <span class="comment">/* CreateGraph */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;Nv; i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;Nv; j++)</span><br><span class="line">            G[i][j] = <span class="number">0</span>; <span class="comment">/* 或INFINITY */</span> </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Ne);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;Ne; i++) &#123;</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;v1, &amp;v2, &amp;w);</span><br><span class="line">         <span class="comment">/* InsertEdge */</span></span><br><span class="line">        G[v1][v2] = w;</span><br><span class="line">        G[v2][v1] = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图的遍历">图的遍历</h2>
<h3 id="深度优先搜索-Depth-First-Search-DFS">深度优先搜索(Depth First Search, DFS)</h3>
<p>类似于树的先序遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span> <span class="params">( Vertex V )</span></span><br><span class="line">&#123; </span><br><span class="line">    visited[V] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> ( V 的每个邻接点 W ) </span><br><span class="line">        <span class="keyword">if</span> ( !visited[W] )</span><br><span class="line">            DFS(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现<br>
以V为出发点对邻接表存储的图Graph进行DFS搜索</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Visit</span><span class="params">( Vertex V )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在访问顶点%d\n&quot;</span>, V);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">( LGraph Graph, Vertex V, <span class="type">void</span> (*Visit)(Vertex) )</span></span><br><span class="line">&#123;  </span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    Visit( V ); </span><br><span class="line">    Visited[V] = <span class="literal">true</span>; </span><br><span class="line">    <span class="comment">/* 对V的每个邻接点W-&gt;AdjV */</span></span><br><span class="line">    <span class="keyword">for</span>( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) </span><br><span class="line">        <span class="keyword">if</span> ( !Visited[W-&gt;AdjV] )    </span><br><span class="line">            DFS( Graph, W-&gt;AdjV, Visit );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜索-Breadth-First-Search-BFS">广度优先搜索(Breadth First Search, BFS)</h3>
<p>层序遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span> <span class="params">( Vertex V )</span></span><br><span class="line">&#123; </span><br><span class="line">    visited[V] = <span class="literal">true</span>;</span><br><span class="line">    Enqueue(V, Q);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        <span class="keyword">for</span> ( V 的每个邻接点 W )        </span><br><span class="line">            <span class="keyword">if</span> ( !visited[W] ) </span><br><span class="line">            &#123;</span><br><span class="line">                visited[W] = <span class="literal">true</span>;</span><br><span class="line">                Enqueue(W, Q);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br></pre></td></tr></table></figure>
<p>实现 邻接矩阵存储的图 - BFS</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEdge</span><span class="params">( MGraph Graph, Vertex V, Vertex W )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Graph-&gt;G[V][W]&lt;INFINITY ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Visited[]为全局变量，已经初始化为false */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span> <span class="params">( MGraph Graph, Vertex S, <span class="type">void</span> (*Visit)(Vertex) )</span></span><br><span class="line">&#123;   <span class="comment">/* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 */</span></span><br><span class="line">    Queue Q;     </span><br><span class="line">    Vertex V, W;</span><br><span class="line"> </span><br><span class="line">    Q = CreateQueue( MaxSize ); <span class="comment">/* 创建空队列, MaxSize为外部定义的常数 */</span></span><br><span class="line">    <span class="comment">/* 访问顶点S：此处可根据具体访问需要改写 */</span></span><br><span class="line">    Visit( S );</span><br><span class="line">    Visited[S] = <span class="literal">true</span>; <span class="comment">/* 标记S已访问 */</span></span><br><span class="line">    AddQ(Q, S); <span class="comment">/* S入队列 */</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span> ( !IsEmpty(Q) ) &#123;</span><br><span class="line">        V = DeleteQ(Q);  <span class="comment">/* 弹出V */</span></span><br><span class="line">        <span class="keyword">for</span>( W=<span class="number">0</span>; W&lt;Graph-&gt;Nv; W++ ) <span class="comment">/* 对图中的每个顶点W */</span></span><br><span class="line">            <span class="comment">/* 若W是V的邻接点并且未访问过 */</span></span><br><span class="line">            <span class="keyword">if</span> ( !Visited[W] &amp;&amp; IsEdge(Graph, V, W) ) &#123;</span><br><span class="line">                <span class="comment">/* 访问顶点W */</span></span><br><span class="line">                Visit( W );</span><br><span class="line">                Visited[W] = <span class="literal">true</span>; <span class="comment">/* 标记W已访问 */</span></span><br><span class="line">                AddQ(Q, W); <span class="comment">/* W入队列 */</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="comment">/* while结束*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 最短路径</p>
<p>在网络中，求两个不同顶点之间的所有路径 中，边的权值之和最小的那一条路径</p>
<p>## 无权图的单源最短路算法</p>
<p>按照递增(非递减)的顺序找出到各个顶 点的最短路</p>
<p>伪码描述:</p>
<p>```c</p>
<p>void Unweighted ( Vertex S )</p>
<p>{</p>
<p>Enqueue(S, Q);</p>
<p>while(!IsEmpty(Q)){</p>
<p>V = Dequeue(Q);</p>
<p>for ( V 的每个邻接点 W )</p>
<p>if(dist[W]==-1 ){</p>
<p>dist[W] = dist[V]+1;</p>
<p>path[W] = V;</p>
<p>Enqueue(W, Q);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>```</p>
<p>实现</p>
<p>无权图的单源最短路算法 -  邻接表存储</p>
<p>dist[] path[]全部初始化为-1</p>
<p>```c</p>
<p>void Unweighted(LGraph Graph, int dist[], int path[], Vertex S){</p>
<p>Queue Q;</p>
<p>Vertex V;</p>
<p>PtrAdjVNode W;</p>
<p>Q = CreateQueue(Graph-&gt;Nv);  // 创建空队列,MaxSize为外部定义的常数</p>
<p>dist[S] = 0; // 初始化源点</p>
<p>AddQ(Q, S);</p>
<p>while (IsEmpty(Q))</p>
<p>{</p>
<p>V = DeleteQ(Q);</p>
<p>for( W = Graph.G[V].FirstEdge; W; W=W-&gt;Next)  // 对V的每个邻接点W-&gt;AdjV</p>
<p>if (dist[W-&gt;AdjV] == -1)</p>
<p>{  // W-&gt;AdjV 未被访问过</p>
<p>dist[W-&gt;AdjV] =dist[V] + 1;  /* W-&gt;AdjV到S的距离更新 */</p>
<p>path[W-&gt;AdjV] = V; /* 将V记录在S到W-&gt;AdjV的路径上 */</p>
<p>AddQ(Q, W-&gt;AdjV);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>```</p>
<p>## 有权图的单源最短路算法</p>
<p>Dijkstra 算法</p>
<p>按照递增的顺序找出到各个顶点的最短路</p>
<ul>
<li>真正的最短路必须只经过S中的顶点</li>
<li>每次从未收录的顶点中选一个dist最小的收录</li>
<li>增加一个v进入S，可能影响另外一个w的dist值</li>
</ul>
<ol>
<li>dist[w] = min{dist[w], dist[v] + &lt;v,w&gt;的权重}</li>
</ol>
<p>伪码</p>
<p>```c</p>
<p>void Dijkstra( Vertex s )</p>
<p>{</p>
<p>while (1){</p>
<p>V = 未收录顶点中dist最小者;</p>
<p>if ( 这样的V不存在 )</p>
<p>break;</p>
<p>collected[V] = true;</p>
<p>for ( V 的每个邻接点 W ){</p>
<p>if ( collected[W] == false ){</p>
<p>if ( dist[V]+E&lt;V,W&gt; &lt; dist[W] ) {</p>
<p>dist[W] = dist[V] + E&lt;V,W&gt; ;</p>
<p>path[W] = V;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>```</p>
<p>算法实现</p>
<p>邻接矩阵存储 - 有权图的单源最短路算法</p>
<p>```c</p>
<p>// 返回未被收录顶点中dist最小值</p>
<p>Vertex FindMinDist(MGraph Graph, int dist[], int collected[]){</p>
<p>Vertex MinV, V;</p>
<p>int MinDist = INFINITY;</p>
<p>for(V=0; V<Graph->Nv; V++){</p>
<p>if (collected[V] = false &amp;&amp; dist[V]&lt; MinDist){  /* 若V未被收录，且dist[V]更小 */</p>
<p>MinDist = dist[V];</p>
<p>MinV = V;  /* 更新对应顶点 */</p>
<p>}</p>
<p>}</p>
<p>if (MinDist &lt; INFINITY) /* 若找到最小dist */</p>
<p>return MinV; /* 返回对应的顶点下标 */</p>
<p>else return ERROR;  /* 若这样的顶点不存在，返回错误标记 */</p>
<p>}</p>
<p>bool Dijkstra(MGraph Graph, int dist[], int path[], Vertex S)</p>
<p>{</p>
<p>int collected[MaxVertexNum];</p>
<p>Vertex V, W;</p>
<p>// 初始化dist[]和path[],邻接矩阵中不存在边的标记为INFINITY</p>
<p>for(V=0; V<Graph->Nv; V++){</p>
<p>dist[V] = Graph-&gt;G[S][V];</p>
<p>if (dist[V]&lt;INFINITY)  // S到V有直接路径</p>
<p>path[V] = S;</p>
<p>else</p>
<p>path[V] = -1;</p>
<p>collected[V] = false;</p>
<p>}</p>
<p>// 先将起点收入到集合中</p>
<p>dist[S] = 0;</p>
<p>collected[S] = true;</p>
<p>while(1)</p>
<p>{</p>
<p>V = FindMinDist(Graph, dist, collected); /* V = 未被收录顶点中dist最小者 */</p>
<p>if (V == ERROR)  /* 若这样的V已经不存在 */</p>
<p>break;</p>
<p>collected[V] = true;</p>
<p>for(W=0; W<Graph->Nv; W++){ // 对图中的每个顶点W</p>
<p>if(collected[W] == false &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY)</p>
<p>{  // 未被收录,且有边(是邻接点)</p>
<p>if ( Graph-&gt;G[V][W]&lt;0 ) /* 若有负边 */</p>
<p>return false; /* 不能正确解决，返回错误标记 */</p>
<p>/* 若收录V使得dist[W]变小 */</p>
<p>if ( dist[V]+Graph-&gt;G[V][W] &lt; dist[W] ) {</p>
<p>dist[W] = dist[V]+Graph-&gt;G[V][W]; /* 更新dist[W] */</p>
<p>path[W] = V; /* 更新S到W的路径 */</p>
<p>}</p>
<p>}</p>
<p>} // for循环结束, 每个V的邻接点W遍历完</p>
<p>}// while结束</p>
<p>return true;</p>
<p>}</p>
<p>```</p>
<p>## 多源最短路算法</p>
<p>Floyd 算法</p>
<p>```c</p>
<p>bool Floyd( MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum] )</p>
<p>{</p>
<p>Vertex i, j, k;</p>
<p>/* 初始化 */</p>
<p>for ( i=0; i<Graph->Nv; i++ )</p>
<p>for( j=0; j<Graph->Nv; j++ ) {</p>
<p>D[i][j] = Graph-&gt;G[i][j];</p>
<p>path[i][j] = -1;</p>
<p>}</p>
<p>for( k=0; k<Graph->Nv; k++ )</p>
<p>for( i=0; i<Graph->Nv; i++ )</p>
<p>for( j=0; j<Graph->Nv; j++ )</p>
<p>if( D[i][k] + D[k][j] &lt; D[i][j] ) {</p>
<p>D[i][j] = D[i][k] + D[k][j];</p>
<p>if ( i==j &amp;&amp; D[i][j]&lt;0 ) /* 若发现负值圈 */</p>
<p>return false; /* 不能正确解决，返回错误标记 */</p>
<p>path[i][j] = k;</p>
<p>}</p>
<p>return true; /* 算法执行完毕，返回正确标记 */</p>
<p>}</p>
<p>```</p>
<p># 排序</p>
<p>## 冒泡排序</p>
<p>稳定!</p>
<p>最好情况:顺序 T = O(N)</p>
<p>最坏情况:逆序 T = O(N^2)</p>
<p>```c</p>
<p>void Swap(ElementType *a, ElementType *b){</p>
<p>ElementType c;</p>
<p>c = *a;</p>
<ul>
<li>a = *b;</li>
<li>b = c;</li>
</ul>
<p>}</p>
<p>void Bubble_Sort(ElementType A[], int N){</p>
<p>int P, i, flag;</p>
<p>for (P=N-1; P&gt;0; P–){  // 最后一位下标是N-1</p>
<p>flag = 0;</p>
<p>for (i=0; i&lt;P; i++){</p>
<p>if(A[i] &gt; A[i+1]){</p>
<p>Swap(&amp;A[i], &amp;A[i+1]);</p>
<p>flag = 1;  // 标识发生了交换</p>
<p>}</p>
<p>}</p>
<p>if (flag==0)</p>
<p>break; // 若全程无交换</p>
<p>}</p>
<p>}</p>
<p>```</p>
<p>## 插入排序</p>
<p>稳定!</p>
<p>最好情况:顺序 T = O(N)</p>
<p>最坏情况:逆序 T = O(N^2)</p>
<p>时间复杂度和逆序对有关 T(N,I) = O(N+I)</p>
<p>定理: 任意N个不同元素组成的序列平均具有 N ( N -1 ) / 4 个逆序对。</p>
<p>简单排序(交换相邻两个数)的时间复杂度下界: Omega(N^2)</p>
<p>```c</p>
<p>void Insertion_Sort(ElementType A[], int N){</p>
<p>ElementType Tmp;</p>
<p>int P, i;</p>
<p>for(P=1; P&lt;N; P++){</p>
<p>Tmp = A[P]; // 摸下一张牌</p>
<p>for (i = P; i&gt;0; i–)</p>
<p>{</p>
<p>if(A[i-1] &gt; Tmp) // 若前一张牌比新摸的牌大</p>
<p>A[i] = A[i-1]; // 移出空位</p>
<p>else break;  // 若新摸的牌比前一张牌大,则跳出循环</p>
<p>}</p>
<p>A[i] = Tmp; // 新牌落位</p>
<p>}</p>
<p>}</p>
<p>```</p>
<p>## 希尔排序</p>
<p>不稳定!</p>
<p>定义增量序列,如Sedgewick增量序列{1,5,19,41,109…}</p>
<p>对每个D进行D间隔的排序</p>
<p>```c</p>
<p>void Shell_Sort(ElementType A[], int N){</p>
<p>int D, P,i;</p>
<p>ElementType Tmp;</p>
<p>for (D=N/2; D&gt;0; D/=2){ // 希尔排序增量</p>
<p>for ( P=D; P&lt;N; P++){  // 插入排序</p>
<p>Tmp = A[P];</p>
<p>for (i = P; i-D&gt;=0; i-=D)</p>
<p>{</p>
<p>if(A[i-D] &gt; Tmp)</p>
<p>A[i] = A[i-D]; // 移出空位</p>
<p>else break;</p>
<p>}</p>
<p>A[i] = Tmp; // 新牌落位</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>```</p>
<p>## 堆排序</p>
<p>不稳定!</p>
<p>选择排序:</p>
<p>```c</p>
<p>void Selection_Sort ( ElementType A[], int N )</p>
<p>{</p>
<p>for(i=0;i&lt;N;i++){</p>
<p>MinPosition = ScanForMin( A, i, N–1 );</p>
<p>Swap( A[i], A[MinPosition] );</p>
<p>}</p>
<p>}</p>
<p>```</p>
<p>重要的是如何找到最小元.</p>
<p>堆排序处理N个不同元素的 随机排列的平均比较次数是2NlogN - O(NloglogN)</p>
<p>用最大堆,交换根节点和最后一个结点,让最大的数到最后,然后减小堆的规模</p>
<p>```c</p>
<p>void PercDown(ElementType A[] , int p, int N)</p>
<p>{// 下滤函数, 将Minheap中以H-&gt;Data[p]为根的子堆调整为最小堆</p>
<p>int parent, child;</p>
<p>ElementType X;</p>
<p>X = A[p]; // 取出根节点的值</p>
<p>for(parent =  p; parent*2+1 &lt;= N-1 ; parent = child)</p>
<p>{</p>
<p>child = parent*2+1;</p>
<p>if( (child != N-1 ) &amp;&amp; (A[child] &lt; A[child+1]))</p>
<p>{</p>
<p>child++;</p>
<p>}</p>
<p>if (X &gt;= A[child])</p>
<p>break;</p>
<p>else // 将X下滤</p>
<p>A[parent] = A[child];</p>
<p>}</p>
<p>A[parent] = X;</p>
<p>}</p>
<p>void Heap_Sort(ElementType A[], int N){</p>
<p>int i;</p>
<p>for (i=N/2; i&gt;=0; i–)  // Build MaxHeap</p>
<p>PercDown(A, i, N);</p>
<p>for (i=N-1; i&gt;0; i–){</p>
<p>Swap(&amp;A[0], &amp;A[i]);  // DeleteMax</p>
<p>PercDown(A, 0, i);  // 重新整理成最大堆,堆的size为i</p>
<p>}</p>
<p>}</p>
<p>```</p>
<p>## 归并排序</p>
<p>稳定!</p>
<p>有序子列的归并</p>
<p>```c</p>
<p>void Merge(ElementType A[], ElementType TmpA[],</p>
<p>int L, int R, int RightEnd)</p>
<p>{</p>
<p>int LeftEnd, Num, Tmp;</p>
<p>int i;</p>
<p>LeftEnd = R - 1;</p>
<p>Tmp = L;  // 存放结果的数组的初始位置</p>
<p>Num = RightEnd - L + 1; // 一共有几个数据</p>
<p>while (L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd){  // 左和右都不为空</p>
<p>if (A[L] &lt;= A[R])</p>
<p>TmpA[Tmp++] = A[L++];</p>
<p>else</p>
<p>TmpA[Tmp++] = A[R++];</p>
<p>}</p>
<p>// 跳出循环时左边还有剩下的</p>
<p>while (L &lt;= LeftEnd)</p>
<p>TmpA[Tmp++] = A[L++];</p>
<p>// 跳出循环时右边还有剩下的</p>
<p>while (R &lt;= RightEnd)</p>
<p>TmpA[Tmp++] = A[R++];</p>
<p>// 把TmpA倒回到A, 从RightEnd倒着复制回去</p>
<p>for(i=0; i&lt;Num; i++){  // 重复Num次</p>
<p>A[RightEnd] = TmpA[RightEnd];</p>
<p>RightEnd–;</p>
<p>}</p>
<p>}</p>
<p>```</p>
<p>递归算法:</p>
<p>```c</p>
<p>void MSort(ElementType A[], ElementType TmpA[], int L, int RightEnd)</p>
<p>{</p>
<p>int Center;</p>
<p>if(L &lt; RightEnd){  // L和RightEnd相等时,就只有一个元素了,不能再分</p>
<p>Center = (L+RightEnd)/2;</p>
<p>// 分</p>
<p>MSort(A, TmpA, L, Center);</p>
<p>MSort(A, TmpA, Center+1, RightEnd);</p>
<p>// 合</p>
<p>Merge(A, TmpA, L, Center+1, RightEnd);</p>
<p>}</p>
<p>}</p>
<p>// 同一接口</p>
<p>void Merge_Sort(ElementType A[], int N){</p>
<p>ElementType *TmpA;  // 临时数组</p>
<p>TmpA = malloc(N * sizeof(ElementType));</p>
<p>if (TmpA != NULL){  // 分配空间成功</p>
<p>MSort(A, TmpA, 0, N-1);</p>
<p>free(TmpA);</p>
<p>}</p>
<p>else</p>
<p>printf(“空间不足\n”);</p>
<p>}</p>
<p>```</p>
<p>T(N) = T(N/2) + T(N/2) + O(N)</p>
<p>T(N) = O(NlogN)</p>
<p>非递归算法</p>
<p>```c</p>
<p>void Merge_Pass(ElementType A[], ElementType TmpA[], int N, int length)  // lenght = 当前有序子列的长度, 一开始等于1</p>
<p>{</p>
<p>int i,j;</p>
<p>for (i=0; i &lt;= N-2*length; i+=2*length) // 留两个length,分情况讨论</p>
<p>Merge(A, TmpA, i, i+length, i+2*length-1); // A TmpA L R RightEnd</p>
<p>if (i+length &lt; N) // 归并最后两个子列</p>
<p>Merge(A, TmpA, i, i+length, N-1);</p>
<p>else  // 最后只剩一个子列, 则复制过来</p>
<p>for (j=i; j&lt;N; j++)</p>
<p>TmpA[j] = A[j];</p>
<p>}</p>
<p>void Merge_sort(ElementType A[], int N){</p>
<p>int length = 1;  // 初始化子序列的长度</p>
<p>ElementType *TmpA;  // 临时数组</p>
<p>TmpA = malloc(N * sizeof(ElementType));</p>
<p>if (TmpA != NULL){  // 分配空间成功</p>
<p>while (length &lt; N){  // 有序子列长度等于N,则完成,跳出循环</p>
<p>Merge_Pass(A, TmpA, N, length);</p>
<p>length *= 2;</p>
<p>Merge_Pass(TmpA, A, N, length);</p>
<p>length *= 2;</p>
<p>}</p>
<p>free(TmpA);</p>
<p>}</p>
<p>else</p>
<p>printf(“空间不足\n”);</p>
<p>}</p>
<p>```</p>
<p>归并排序是稳定的</p>
<p>## 快速排序</p>
<p>不稳定</p>
<p>主元一次性放到正确的位置上</p>
<p>主元左边的都比主元小,右边的都比主元大</p>
<p>```c</p>
<p>// 选主元 pivot</p>
<p>ElementType Median3(ElementType A[], int Left, int Right){</p>
<p>int Center = (Left + Right) / 2;</p>
<p>// 整理成 A[Left] &lt;= A[Center] &lt;= A[Right]</p>
<p>if (A[Left] &gt; A[Center])</p>
<p>Swap(&amp;A[Left], &amp;A[Right]);</p>
<p>if (A[Left] &gt; A[Right])</p>
<p>Swap(&amp;A[Left], &amp;A[Right]);</p>
<p>if (A[Center] &gt; A[Right])</p>
<p>Swap(&amp;A[Center], &amp;A[Right]);</p>
<p>// 将基准Pivot藏到右边Right-1处, 则之后只需考虑 A[Left+1] -&gt; A[Right-2]</p>
<p>Swap(&amp;A[Center], &amp;A[Right-1]);</p>
<p>return A[Right-1];</p>
<p>}</p>
<p>void Qsort(ElementType A[], int Left, int Right){</p>
<p>int Pivot, Cutoff, Low, High;</p>
<p>// 如果序列元素足够多,则进入快排</p>
<p>Cutoff = 4;</p>
<p>if (Cutoff &lt;= Right - Left){</p>
<p>Pivot = Median3(A, Left, Right);</p>
<p>Low = Left;</p>
<p>High = Right-1;</p>
<p>while(1){</p>
<p>while(A[++Low] &lt; Pivot);  // 一直循环,直到A[Low] &gt;= Pivot, 停住</p>
<p>while(A[–High] &gt; Pivot);  // 一直循环,直到A[Hight] &lt;= Pivot, 停住</p>
<p>if (Low&lt;High)</p>
<p>Swap(&amp;A[Low], &amp;A[High]);</p>
<p>else // Low &gt; High low已经越过了high,子序列排序结束</p>
<p>break;</p>
<p>}</p>
<p>Swap(&amp;A[Low], &amp;A[Right-1]);  // 将Pivot归位,此时 Low&gt;High, 所以Pivot和Low交换</p>
<p>Qsort(A, Left, Low-1);   // 递归Pivot左边</p>
<p>Qsort(A, Low+1, Right);    // 递归Pivot右边</p>
<p>}</p>
<p>else // 元素太少,用简单排序</p>
<p>Insertion_Sort(A+Left, Right-Left+1);  // 待排序列表A从Left开始,即A+Left, 长度是R-L+1</p>
<p>}</p>
<p>void Quick_Sort(ElementType A[], int N){</p>
<p>Qsort(A, 0 ,N-1);</p>
<p>}</p>
<p>```</p>
<p>## 选择排序</p>
<p>不稳定</p>
<p>```c</p>
<p>#define MaxDigit 3  // 假设最大为三位数</p>
<p>#define Radix 10  // 十进制</p>
<p>/* 桶元素结点 */</p>
<p>typedef struct Node *PtrNode;</p>
<p>struct Node</p>
<p>{</p>
<p>int key;</p>
<p>PtrNode next;</p>
<p>};</p>
<p>/* 桶头结点 */</p>
<p>struct HeadNode</p>
<p>{</p>
<p>PtrNode head;</p>
<p>PtrNode tail;</p>
<p>};</p>
<p>typedef struct HeadNode Bucket[Radix];</p>
<p>/* 返回整型关键字X的第D位数字 */</p>
<p>int GetDigit(int X, int D){</p>
<p>// 默认次位D=1, 主位 D&lt;= MaxDigit</p>
<p>int d, i;</p>
<p>for(i=1; i&lt;=D; i++){</p>
<p>d = X % Radix;</p>
<p>X /= Radix;</p>
<p>}</p>
<p>return d;</p>
<p>}</p>
<p>// 次位优先(Least Significant Digit)排序</p>
<p>void LSDRadix_Sort(ElementType A[], int N){</p>
<p>int D, Di, i;</p>
<p>Bucket B;</p>
<p>PtrNode tmp, p, List=NULL;</p>
<p>// 初始化每个桶为空链表</p>
<p>for(i=0; i&lt;Radix; i++)</p>
<p>B[i].head = B[i].tail = NULL;</p>
<p>// 将原始序列A[], 逆序(插在链表头)存入链表List</p>
<p>for(i=0; i&lt;N; i++){</p>
<p>tmp = (PtrNode)malloc(sizeof(struct Node));</p>
<p>tmp-&gt;key = A[i];</p>
<p>tmp-&gt;next = List;</p>
<p>List = tmp;</p>
<p>}</p>
<p>// 开始排序</p>
<p>for (D=1; D&lt;= MaxDigit; D++){  // 对数据的每一位循环处理</p>
<p>p=List;</p>
<p>while(p)</p>
<p>{</p>
<p>Di = GetDigit(p-&gt;key, D);  // 获得当前元素的第D位数字</p>
<p>// 从链表P中删除结点</p>
<p>tmp = p;</p>
<p>p = p-&gt;next;</p>
<p>tmp-&gt;next = NULL;</p>
<p>// 把结点插入到对应的B[Di]桶里</p>
<p>if (B[Di].head == NULL)</p>
<p>B[Di].head = B[Di].tail = tmp;</p>
<p>else{</p>
<p>B[Di].tail-&gt;next = tmp; // 把tmp加在尾部</p>
<p>B[Di].tail = tmp;  // 尾部指向最后一个结点,即tmp</p>
<p>}</p>
<p>}  // while循环结束, 以第D位的分配完毕</p>
<p>// D位数排完以后开始收集</p>
<p>List = NULL;</p>
<p>for(Di=Radix-1; Di &gt;= 0; Di–)  // 将诶个桶的元素顺序收入List, 因为每次插入到List的头部,所以要从9开始收</p>
<p>{</p>
<p>if (B[Di].head){</p>
<p>B[Di].tail-&gt;next = List;</p>
<p>List = B[Di].head;</p>
<p>B[Di].head = B[Di].tail = NULL;  // 清空桶</p>
<p>}</p>
<p>}</p>
<p>}// 大for循环结束</p>
<p>// 将List[]导入A[], 并释放空间</p>
<p>for(i=0; i&lt;N; i++){</p>
<p>tmp = List;</p>
<p>List = List-&gt;next;</p>
<p>A[i] = tmp-&gt;key;</p>
<p>free(tmp);</p>
<p>}</p>
<p>}</p>
<p>```</p>
<p>时间复杂度 T = O(P(N+B))</p>
<p>当B较小时,基本是线性的.</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2024/10/05/%E9%9D%A1%E4%B8%8D%E6%9C%89%E5%88%9D%EF%BC%8C%E9%B2%9C%E5%85%8B%E6%9C%89%E7%BB%88/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
              2024-10-14 17:56:01
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="分类"></i>
                    
                    <span class="span--category">
                      <a href="/categories/%E5%AD%A6%E7%82%B9%E4%BB%80%E4%B9%88/" title="学点什么">
                        <b>#</b> 学点什么
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2024/12/24/%E5%86%8D%E7%9C%8B%E8%9B%99%E6%B1%A0%E5%92%8C%E5%8E%BB%E5%8C%97%E4%BA%AC/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">抽象数据类型 Abstract Data Type</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">实例： 最大子列和问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%B8%80%EF%BC%9A"><span class="toc-text">算法一：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BA%8C-%E5%8E%BB%E6%8E%89K%E8%BF%99%E4%B8%AA%E5%BE%AA%E7%8E%AF"><span class="toc-text">算法二, 去掉K这个循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%B8%89%EF%BC%9A-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="toc-text">算法三： 分而治之</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%9B%9B%EF%BC%9A-%E5%9C%A8%E7%BA%BF%E5%A4%84%E7%90%86"><span class="toc-text">算法四： 在线处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">线性结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8-Linear-List"><span class="toc-text">线性表 Linear List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">线性存储序列的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">链式存储的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">广义表  Generalized List</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">堆栈 Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">栈的顺序存储实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E"><span class="toc-text">堆栈的链式存储实</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">应用:表达式求值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">队列 Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">队列的顺序存储实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">队列的链式存储实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-text">应用: 多项式加法运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">树与树的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE-Sequential-Search"><span class="toc-text">静态查找 Sequential Search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-Binary-Search"><span class="toc-text">二分查找 Binary Search</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91-Tree"><span class="toc-text">树 Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9"><span class="toc-text">输出二叉树叶子节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6"><span class="toc-text">求二叉树的高度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">层序生成二叉树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">二叉搜索树 Binary Search Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-text">查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%9C%80%E5%A4%A7%E5%80%BC-%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">返回最大值&#x2F;最小值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-text">插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">平衡二叉树  Balanced Binary Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E6%95%B4"><span class="toc-text">调整</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">堆 Heap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-text">结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-2"><span class="toc-text">插入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">删除</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">哈夫曼树与哈夫曼编码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">集合及运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E6%89%80%E5%9C%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-text">查找某个元素所在的集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6%E8%BF%90%E7%AE%97"><span class="toc-text">集合的并运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">图 Graph</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%9B%BE"><span class="toc-text">建立图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-Depth-First-Search-DFS"><span class="toc-text">深度优先搜索(Depth First Search, DFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-Breadth-First-Search-BFS"><span class="toc-text">广度优先搜索(Breadth First Search, BFS)</span></a></li></ol></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        
  <div id="waline-comments"></div>

  <script>
    function loadWalineSuc(func) {
      func({
        el: '#waline-comments',
        path: location.pathname,
        serverURL: 'waline.qaqan.cn',
        emoji: true,
        dark: 'html[color-mode="dark"]',
        requiredMeta: ['nick'],
        wordLimit: 150,
        imageUploader: false,
        search: false,
        reaction: false,
        pageSize: 30,
        lang: 'zh-CN'
      })
    }
  </script>

  
    <link rel="stylesheet" href="https://unpkg.com/@waline/client@v3/dist/waline.css">
    <script type="module">
      import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js'
      loadWalineSuc(init)
    </script>
  








      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/jiangdong12138">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        Copyright © 2025 Nullptr
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索关键词">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        

      </div>
    </div>
  </body>
</html>
