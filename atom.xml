<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Soieknife</title>
  
  <subtitle>近人可读</subtitle>
  <link href="https://qaqan.cn/atom.xml" rel="self"/>
  
  <link href="https://qaqan.cn/"/>
  <updated>2025-09-25T02:28:51.878Z</updated>
  <id>https://qaqan.cn/</id>
  
  <author>
    <name>Nullptr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我本来就不会写作</title>
    <link href="https://qaqan.cn/2025/09/22/%E6%88%91%E6%9C%AC%E6%9D%A5%E5%B0%B1%E4%B8%8D%E4%BC%9A%E5%86%99%E4%BD%9C/"/>
    <id>https://qaqan.cn/2025/09/22/%E6%88%91%E6%9C%AC%E6%9D%A5%E5%B0%B1%E4%B8%8D%E4%BC%9A%E5%86%99%E4%BD%9C/</id>
    <published>2025-09-22T15:02:36.000Z</published>
    <updated>2025-09-25T02:28:51.878Z</updated>
    
    <content type="html"><![CDATA[<p><strong>我曾经被认为擅长写作。</strong></p><span id="more"></span><p>这是一个美丽的错误：我那些所谓的灵气全然来自我过早接触了言情杂志。这些杂志来自我姐，很不幸，我被言情小说毒害的年纪要早于她。它们是爱格、小说绘和郭敬明，危害程度依次递减。爱格让我早恋，小说绘向我普及了BL，郭敬明让我对不能驾驭的修辞保持谨慎。</p><p>我痛恨写作。我写作文时用到的东西，全都是刻板的谎言。我尽力模仿我读过的小说，我喜欢那些华彩的字词和匠气有余的修辞。它们越好，我就就更痛苦：那些词句从我笔尖流过的时候，我知道仅仅是流过了。除非记住，否则我永远也没办法写出一样的东西。我的生活只有田野、鸡叫和难看的电视节目。</p><p>我也痛恨写风景。我没办法感受到风景文里的美。我时常用壮观、雄奇这两个形容词，在写下他们的时候，我的心绪和写下其他平淡的词一样没有波动。十年过去，我从未有一刻感受过这两个词语，哪怕我已经去了很多可被称为壮观的地方。我忍着恶心编造一篇又一篇游记。幸运的是，我不再用继续编造了。感谢大学！</p><p>靠着词汇储备，哪怕对整个写作过程感到痛苦，我还是得到了不错的评价。老师们认为我擅长写作、“有灵气”。这种灵气来源于模仿带来的破碎：造作的描写、华丽的词汇、完成度偏低的故事。</p><p>不过，高二以后就没人再这么觉得了。我换了一位在语文教学方面浸淫数十年的男教师，他讲课很浮夸，不过对作文的指导非常朴实，倡导的那种工整的作文，擅长把两个狗屁不通的东西用狗屁不通的修辞做成对仗的标题。我不会写作文，也不喜欢他，他时常骂我。</p><p>我不擅长写作的事实很快就被广泛接受。在没人知道的角落，我也很愉快地接受了伤仲永^-^。我原以为我只是没有那种才气，现在发现是蠢于写作。我竟然还用了一段江郎作QQ昵称，太好笑了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;我曾经被认为擅长写作。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="post" scheme="https://qaqan.cn/categories/post/"/>
    
    
  </entry>
  
  <entry>
    <title>这个世界会好吗</title>
    <link href="https://qaqan.cn/2025/07/06/%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E4%BC%9A%E5%A5%BD%E5%90%97/"/>
    <id>https://qaqan.cn/2025/07/06/%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E4%BC%9A%E5%A5%BD%E5%90%97/</id>
    <published>2025-07-06T14:11:45.000Z</published>
    <updated>2025-09-22T13:16:55.399Z</updated>
    
    <content type="html"><![CDATA[<p>“当一个人意识到自己的生命有限，他就不再会继续投入任何创造事业里”。</p><span id="more"></span><p>有两个群体的苦难我一直不忍卒读：老人们、小狗们，他们在笔者的童年各有一个沉默的剪影。</p><p>先说老人们。</p><p>小学五年级的时候，学校突然组建了一个学生乐团，在很短的时间内召集和培训了一群小学生吹锣打鼓。很快，这个小乐团接到了第一个活：慰问养老院。笔者有幸参与其中，不过不打鼓，纯站。</p><p>养老院特别小，就在学校附近的一条巷子。进去的时候，院子里已经摆好了几排椅子，老头们一瘸一拐从食堂走出来。</p><p>食堂地面的白色瓷砖上是刚拖过地留下的水渍。这样的水渍出现在养老院是很奇怪的。</p><p>老师开始指挥乐团轰轰烈烈地吹锣打鼓。</p><p>读者可以想象那个画面：一群行将就木、表情呆板的老头坐在座位上看一群小孩吹喇叭敲锣、喜形于色。孩子们兴致勃勃。他们还意识不到这场慰问是一种赋予，自己潦草、尚且短暂的生命在那刻找到了可以凌驾的主体。</p><p>接着学生们开始四散，探望每个房间的老人。这个养老院有两层，我很快就跑到二楼的某个房间。入目是一片黑暗。一位老人佝偻在床上，床头放着咬了一块的点心。他问我：</p><p><em>这么热闹，外边是娶媳妇嘞？</em></p><p>笔者已经全然忘记二楼房间的具体情形，唯独记得那种特殊的黑暗：带着馊味、从走廊跨进房间的刹那会产生迷失错觉。伙伴们也踏进来，紧接着被养老院的年轻负责人呵斥走。这一画面应该只有笔者看清楚。</p><p>我尝试和人分享这种难以言明的黑暗，这很困难，我不知道怎么说。不过，笔者当时只是一个小孩。黑暗之间令我茫然无措的东西，在十年后才显露面目：那就是衰老、死亡，还有这两者之间的疾病。</p><p>十年过去，笔者的母校——独树镇英才小学，因为火灾造成的死亡事故，被撤销停办了。曾组织起这个乐队的年轻校长也关了监狱。希望孩子们在地下好。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;“当一个人意识到自己的生命有限，他就不再会继续投入任何创造事业里”。&lt;/p&gt;</summary>
    
    
    
    <category term="post" scheme="https://qaqan.cn/categories/post/"/>
    
    
  </entry>
  
  <entry>
    <title>无意义豆豆图</title>
    <link href="https://qaqan.cn/2025/06/02/%E6%97%A0%E6%84%8F%E4%B9%89%E5%B0%8F%E7%8B%97%E5%9B%BE/"/>
    <id>https://qaqan.cn/2025/06/02/%E6%97%A0%E6%84%8F%E4%B9%89%E5%B0%8F%E7%8B%97%E5%9B%BE/</id>
    <published>2025-06-01T16:38:02.000Z</published>
    <updated>2025-07-30T08:40:54.378Z</updated>
    
    <content type="html"><![CDATA[<p>已经是肥美豆豆了。<br><img src="/images/dd1.jpg" alt="豆豆" loading="lazy"></p><p><img src="/images/dd.jpg" alt="豆豆" loading="lazy"></p><p><img src="/images/dd2.jpg" alt="豆豆" loading="lazy"></p><p><img src="/images/dd3.jpg" alt="豆豆" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;已经是肥美豆豆了。&lt;br&gt;
&lt;img src=&quot;/images/dd1.jpg&quot; alt=&quot;豆豆&quot; loading=&quot;lazy&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dd.jpg&quot; alt=&quot;豆豆&quot; loading=&quot;lazy&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img s</summary>
      
    
    
    
    <category term="live" scheme="https://qaqan.cn/categories/live/"/>
    
    
    <category term="狗" scheme="https://qaqan.cn/tags/%E7%8B%97/"/>
    
  </entry>
  
  <entry>
    <title>我祈祷拥有一颗透明的心灵</title>
    <link href="https://qaqan.cn/2025/06/01/%E6%88%91%E7%A5%88%E7%A5%B7%E6%8B%A5%E6%9C%89%E4%B8%80%E9%A2%97%E9%80%8F%E6%98%8E%E7%9A%84%E5%BF%83%E7%81%B5/"/>
    <id>https://qaqan.cn/2025/06/01/%E6%88%91%E7%A5%88%E7%A5%B7%E6%8B%A5%E6%9C%89%E4%B8%80%E9%A2%97%E9%80%8F%E6%98%8E%E7%9A%84%E5%BF%83%E7%81%B5/</id>
    <published>2025-06-01T11:23:16.000Z</published>
    <updated>2025-07-30T10:41:05.596Z</updated>
    
    <content type="html"><![CDATA[<p>告别春天，进入天高云阔的夏天以后，睡眠突然减少了。感谢这部分多出来的时间，我又开始想。<span id="more"></span></p><p>四月，经历了我姐的婚礼，小狗第一次来姨妈，两场演出。期待了很多事情。我姐比我多出的九年生命长度，在婚礼那刻被细细剪开。一家人对着剪断的丝丝缕缕难过，哭过几场之后生活也没什么不一样。婚姻对女方家是一场精心设计的巧取豪夺。我姐展现出来的成熟姿态让我惭愧。我对我姐的崇拜，又变得崇高了。</p><p>小狗长大很多，毛摸着还是糙糙的。她不喜欢穿衣服，也不爱穿纸尿裤，考虑绝育，不过绝育要切子宫，不舍得小狗难受，还不知道怎么办好。想到这里特别惊叹文字的能力：写出小狗这两个字的时候，想象里也出现一张圆狗脸。昨晚收到一张豆豆wink的照片，不知道怎么学来的。</p><p>五月，特别期待的演出在原定日期的前一天取消了。</p><p>今年经受了很多对审美的考验：好像不再能接受蛙池这类写作不能传达思想之流，也再没有耐心听思江念诗，听晕车车的时候会觉得吵耳朵。对着网易云茫然，随机到的歌听起来不再悦耳了。这是因为我得到了审美的长进，还是过往喜欢的支撑——那种精神上的刻奇不再稳固了？</p><p>刻奇，这个新鲜的词，我从播客里学到它。整个春天记在微信收藏里的漂亮字眼还有不少，什么牝鸡司晨、荷丝难杀。</p><p>春天里还在读潮湿的台湾文学，看陈绮贞、安溥的演出，看文艺片的拉片，支持所有性取向。夏天以后突然觉得无趣：喜欢如果没有门槛，那也同样没有纵深，进入和离开都不值得自矜。既然喜欢上这些东西的时候没有什么阻碍，那放弃的时候也不应该痛苦。我和它们之间的联系本就细若游丝。</p><p>春夏之交的那个夜晚，多少人悄悄背叛了春天曾共鸣的所有感情？幸运的是，我仍然喜欢摇滚乐。</p><p><strong>你原谅我吧，年轻时会辜负一些人，就像春天会有必死无疑的花香。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;告别春天，进入天高云阔的夏天以后，睡眠突然减少了。感谢这部分多出来的时间，我又开始想。</summary>
    
    
    
    <category term="post" scheme="https://qaqan.cn/categories/post/"/>
    
    
  </entry>
  
  <entry>
    <title>5-11 钢心</title>
    <link href="https://qaqan.cn/2025/05/12/%E9%92%A2%E5%BF%83/"/>
    <id>https://qaqan.cn/2025/05/12/%E9%92%A2%E5%BF%83/</id>
    <published>2025-05-12T12:19:15.000Z</published>
    <updated>2025-07-30T10:40:55.533Z</updated>
    
    <content type="html"><![CDATA[<p>朋友圈看见郑州开了新的livehouse，买票去看了一小时的钢心。</p><p>之前就听钢心，只是没有想到主唱是摇滚老头。18岁的男孩水灵，54岁的老头三倍水灵。</p><p>现场很好，大家都很开心。</p><span id="more"></span><p><img src="/images/gx_1.jpg" alt="海报" loading="lazy"></p><p><img src="/images/gx_2.jpg" alt="老头" loading="lazy"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;朋友圈看见郑州开了新的livehouse，买票去看了一小时的钢心。&lt;/p&gt;
&lt;p&gt;之前就听钢心，只是没有想到主唱是摇滚老头。18岁的男孩水灵，54岁的老头三倍水灵。&lt;/p&gt;
&lt;p&gt;现场很好，大家都很开心。&lt;/p&gt;</summary>
    
    
    
    <category term="live" scheme="https://qaqan.cn/categories/live/"/>
    
    
    <category term="摇滚乐" scheme="https://qaqan.cn/tags/%E6%91%87%E6%BB%9A%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>4.6 刺猬 我疯了</title>
    <link href="https://qaqan.cn/2025/04/07/4-6%E6%88%91%E7%96%AF%E4%BA%86/"/>
    <id>https://qaqan.cn/2025/04/07/4-6%E6%88%91%E7%96%AF%E4%BA%86/</id>
    <published>2025-04-07T15:26:46.000Z</published>
    <updated>2025-07-30T10:40:58.937Z</updated>
    
    <content type="html"><![CDATA[<p>认识刺猬也是在那个暑假，5年过去终于看到现场，留下纪念。特别喜欢那种以头抢地的生命力。</p><span id="more"></span><p><img src="/images/cw_post.jpg" alt="logo" loading="lazy"></p><center/><i>歌词<i><center/><p><img src="/images/cw_1.jpg" alt="1" loading="lazy"></p><center/><i>赵子建。<i><center/><p><img src="/images/cw_2.jpg" alt="2" loading="lazy"></p><center/><i>西西 键盘<i><center/><p><img src="/images/cw_3.jpg" alt="3" loading="lazy"></p><center/><i>一帆<i><center/><p><video src="/images/cw_live.mp4" position= "absolute" width="100%" height="100%" controls="controls"></video></p><center/><i>现场<i><center/>]]></content>
    
    
    <summary type="html">&lt;p&gt;认识刺猬也是在那个暑假，5年过去终于看到现场，留下纪念。特别喜欢那种以头抢地的生命力。&lt;/p&gt;</summary>
    
    
    
    <category term="live" scheme="https://qaqan.cn/categories/live/"/>
    
    
    <category term="摇滚乐" scheme="https://qaqan.cn/tags/%E6%91%87%E6%BB%9A%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>java学习</title>
    <link href="https://qaqan.cn/2025/03/26/java%E5%AD%A6%E4%B9%A0/"/>
    <id>https://qaqan.cn/2025/03/26/java%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-03-26T11:32:07.000Z</published>
    <updated>2025-07-30T10:42:48.740Z</updated>
    
    <content type="html"><![CDATA[<h1>Java 学习路径</h1><h2 id="学习计划">学习计划</h2><ul><li>[x] 掌握 Java 基础语法</li><li>[x] 学习面向对象编程（OOP）概念</li><li>[x] 熟悉常用数据结构和算法</li><li>[ ] 学习 Java 标准库（如集合框架、IO 等）</li><li>[ ] 掌握多线程编程</li><li>[ ] 学习网络编程</li><li>[ ] 完成一个小型项目</li></ul><h2 id="学习情况">学习情况</h2><h3 id="Day-0：">Day 0：</h3><pre><code>新建了文件夹。</code></pre><h3 id="Day-5">Day 5:</h3><pre><code>啥也没干。后天要去讲数据库了放一放。</code></pre><h4 id="Day-N">Day N:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">哎呦又啥也没干，我的智力就这么刚好够抄完各种作业。</span><br></pre></td></tr></table></figure><h4 id="DAYN-…">DAYN+…</h4><p>期末考前那晚看了一宿，考了80。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java 学习路径&lt;/h1&gt;
&lt;h2 id=&quot;学习计划&quot;&gt;学习计划&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[x] 掌握 Java 基础语法&lt;/li&gt;
&lt;li&gt;[x] 学习面向对象编程（OOP）概念&lt;/li&gt;
&lt;li&gt;[x] 熟悉常用数据结构和算法&lt;/li&gt;
&lt;li&gt;[ ] 学习 J</summary>
      
    
    
    
    <category term="code" scheme="https://qaqan.cn/categories/code/"/>
    
    
  </entry>
  
  <entry>
    <title>一元稀疏多项式的计算</title>
    <link href="https://qaqan.cn/2024/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%A7%E4%BD%9C%E4%B8%9A%E7%95%99%E5%BF%B5/"/>
    <id>https://qaqan.cn/2024/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%A7%E4%BD%9C%E4%B8%9A%E7%95%99%E5%BF%B5/</id>
    <published>2024-12-24T08:31:25.000Z</published>
    <updated>2025-07-30T08:49:00.483Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>什么是一元稀疏多项式？</p><p>是指只有一个未知数，且多项式中非零系数项的数量远少于总项数的多项式。其一般形式可以表示为：P(x) = a<em>nx^n + a</em>{n-1}x^{n-1} + … + a_1x + a_0，其中n为多项式的最高次数，a_i为第i项的系数，且大部分a_i为0。</p></blockquote><p>将项抽象为一个类后，不难发现，需要处理到的难点有：将输入、输出时字符串与类的相互转换，运算符优先级和括号的匹配，以及数学建模。用到的C++特性有：类、模板、栈、运算符重载、构造函数和析构函数。最终的功能实现有：多项式间的加、减、乘、除，任意阶微分和部分多项式的任意阶积分。<em><strong>（不考虑-1阶幂函数的求积分）</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//util.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;polynomial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mstack.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">polynomialToString</span><span class="params">(Polynomial p)</span></span>;</span><br><span class="line"><span class="function">Polynomial <span class="title">singleStringToPolynomial</span><span class="params">(std::string s)</span></span>;</span><br><span class="line"><span class="function">Polynomial <span class="title">mainParse</span><span class="params">(std::string &amp;s)</span></span>;</span><br><span class="line"><span class="comment">//terms.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Term</span> <span class="comment">// 项</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Term</span>();</span><br><span class="line">    <span class="built_in">Term</span>(<span class="type">double</span> c, <span class="type">int</span> e);</span><br><span class="line">    <span class="type">double</span> coefficient = <span class="number">0</span>; <span class="comment">// 系数</span></span><br><span class="line">    <span class="type">int</span> exponent = <span class="number">0</span>;    <span class="comment">// 指数</span></span><br><span class="line">    Term* front = <span class="literal">nullptr</span>;</span><br><span class="line">    Term* next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Polynomial.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;term.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span> &#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  Term *head = <span class="literal">nullptr</span>;</span><br><span class="line">  Term *tail = <span class="keyword">new</span> <span class="built_in">Term</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">Polynomial</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">put</span><span class="params">(<span class="type">double</span> coefficient, <span class="type">int</span> exponent)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">double</span> coefficient, <span class="type">int</span> exponent)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Term *<span class="title">getHead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Term *<span class="title">getTail</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Polynomial <span class="title">calc</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Polynomial <span class="title">diff</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">  Polynomial <span class="keyword">operator</span>+(Polynomial &amp;p);</span><br><span class="line"></span><br><span class="line">  Polynomial <span class="keyword">operator</span>-(Polynomial &amp;p);</span><br><span class="line"></span><br><span class="line">  Polynomial <span class="keyword">operator</span>*(Polynomial &amp;p);</span><br><span class="line"></span><br><span class="line">  Polynomial <span class="keyword">operator</span>/(Polynomial &amp;p);</span><br><span class="line"></span><br><span class="line">  Polynomial &amp;<span class="keyword">operator</span>=(Polynomial &amp;p);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;calc.h&quot;</span></span></span><br><span class="line"><span class="comment">//cal.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;polynomial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;term.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">addOrSub</span><span class="params">(Polynomial &amp;a, Polynomial &amp;b, <span class="type">bool</span> add)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">mul</span><span class="params">(Polynomial &amp;a, Polynomial &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">div</span><span class="params">(Polynomial a, Polynomial &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">ccalc</span><span class="params">(Polynomial &amp;a, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">cdiff</span><span class="params">(Polynomial &amp;a, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mstack.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mstack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(Ty x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//arr[++topPos] = x;</span></span><br><span class="line">        arr.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Ty <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//return arr[topPos];</span></span><br><span class="line">        <span class="keyword">return</span> arr.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// if (topPos &gt;= 0) &#123;</span></span><br><span class="line">        <span class="comment">//     topPos--;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        arr.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return topPos == -1;</span></span><br><span class="line">        <span class="keyword">return</span> arr.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//topPos = -1;</span></span><br><span class="line">        arr.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//Ty arr[5]&#123;&#125;; //1000</span></span><br><span class="line">    std::vector&lt;Ty&gt; arr;</span><br><span class="line">    <span class="comment">//int topPos = -1;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line">                                           <span class="comment">//plcynomail.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;polynomial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;calc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Polynomial::~<span class="built_in">Polynomial</span>() &#123;</span><br><span class="line">  <span class="comment">// clear();</span></span><br><span class="line">  <span class="comment">// delete tail;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Polynomial::put</span><span class="params">(<span class="type">double</span> coefficient, <span class="type">int</span> exponent)</span> </span>&#123;</span><br><span class="line">  Term *node = <span class="keyword">new</span> <span class="built_in">Term</span>(coefficient, exponent);</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    head = node;</span><br><span class="line">    head-&gt;next = tail;</span><br><span class="line">    tail-&gt;front = head;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Term *term = <span class="built_in">getHead</span>(); term != tail; term = term-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (term-&gt;exponent &lt; exponent) &#123;</span><br><span class="line">      <span class="keyword">if</span> (term-&gt;front != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        node-&gt;front = term-&gt;front;</span><br><span class="line">        node-&gt;next = term;</span><br><span class="line">        term-&gt;front-&gt;next = node;</span><br><span class="line">        term-&gt;front = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = head;</span><br><span class="line">        head-&gt;front = node;</span><br><span class="line">        head = node;</span><br><span class="line">      &#125;</span><br><span class="line">      n++;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (term-&gt;exponent == exponent)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  node-&gt;front = tail-&gt;front;</span><br><span class="line">  node-&gt;next = tail;</span><br><span class="line">  tail-&gt;front-&gt;next = node;</span><br><span class="line">  tail-&gt;front = node;</span><br><span class="line">  n++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Polynomial::update</span><span class="params">(<span class="type">double</span> coefficient, <span class="type">int</span> exponent)</span> </span>&#123;</span><br><span class="line">  Term *node = <span class="keyword">new</span> <span class="built_in">Term</span>(coefficient, exponent);</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    head = node;</span><br><span class="line">    head-&gt;next = tail;</span><br><span class="line">    tail-&gt;front = head;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Term *term = <span class="built_in">getHead</span>(); term != tail; term = term-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (term-&gt;exponent &lt; exponent) &#123;</span><br><span class="line">      <span class="keyword">if</span> (term-&gt;front != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        node-&gt;front = term-&gt;front;</span><br><span class="line">        node-&gt;next = term;</span><br><span class="line">        term-&gt;front-&gt;next = node;</span><br><span class="line">        term-&gt;front = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = head;</span><br><span class="line">        head-&gt;front = node;</span><br><span class="line">        head = node;</span><br><span class="line">      &#125;</span><br><span class="line">      n++;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (term-&gt;exponent == exponent) &#123;</span><br><span class="line">      term-&gt;coefficient += coefficient;</span><br><span class="line">      <span class="keyword">if</span> (term-&gt;front-&gt;coefficient &gt; <span class="number">-0.0000000005</span> &amp;&amp;</span><br><span class="line">          term-&gt;front-&gt;coefficient &lt; <span class="number">0.000000000</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (term == head)</span><br><span class="line">          head = term-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          term-&gt;front-&gt;next = term-&gt;next, term-&gt;next-&gt;front = term-&gt;front;</span><br><span class="line">        <span class="keyword">delete</span> term;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  node-&gt;front = tail-&gt;front;</span><br><span class="line">  node-&gt;next = tail;</span><br><span class="line">  tail-&gt;front-&gt;next = node;</span><br><span class="line">  tail-&gt;front = node;</span><br><span class="line">  n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Polynomial::clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (Term *node = <span class="built_in">getHead</span>(); node != <span class="literal">nullptr</span> &amp;&amp; node != tail;) &#123;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> node-&gt;front;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Polynomial::size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Polynomial::normalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Term *node = <span class="built_in">getHead</span>(); node != <span class="literal">nullptr</span> &amp;&amp; node != tail;) &#123;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;front-&gt;coefficient &gt; <span class="number">-0.0000000005</span> &amp;&amp;</span><br><span class="line">        node-&gt;front-&gt;coefficient &lt; <span class="number">0.0000000005</span>) &#123;</span><br><span class="line">      Term *term = node-&gt;front;</span><br><span class="line">      <span class="keyword">if</span> (term == head)</span><br><span class="line">        head = node;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;front = term-&gt;front;</span><br><span class="line">        node-&gt;front-&gt;front-&gt;next = node;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> term;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Term *<span class="title">Polynomial::getHead</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Term *<span class="title">Polynomial::getTail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> tail; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">Polynomial::calc</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ccalc</span>(*<span class="keyword">this</span>, n); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">Polynomial::diff</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">cdiff</span>(*<span class="keyword">this</span>, n); &#125;</span><br><span class="line"></span><br><span class="line">Polynomial Polynomial::<span class="keyword">operator</span>+(Polynomial &amp;p) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">addOrSub</span>(*<span class="keyword">this</span>, p, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Polynomial Polynomial::<span class="keyword">operator</span>-(Polynomial &amp;p) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">addOrSub</span>(*<span class="keyword">this</span>, p, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Polynomial Polynomial::<span class="keyword">operator</span>*(Polynomial &amp;p) &#123; <span class="keyword">return</span> <span class="built_in">mul</span>(*<span class="keyword">this</span>, p); &#125;</span><br><span class="line"></span><br><span class="line">Polynomial Polynomial::<span class="keyword">operator</span>/(Polynomial &amp;p) &#123; <span class="keyword">return</span> <span class="built_in">div</span>(*<span class="keyword">this</span>, p); &#125;</span><br><span class="line"></span><br><span class="line">Polynomial &amp;Polynomial::<span class="keyword">operator</span>=(Polynomial &amp;p) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;p)</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  Term *last = tail;</span><br><span class="line">  n = p.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (Term *node = p.<span class="built_in">getTail</span>(); node-&gt;front != <span class="literal">nullptr</span>; node = node-&gt;front) &#123;</span><br><span class="line">    Term *term = <span class="keyword">new</span> <span class="built_in">Term</span>(node-&gt;front-&gt;coefficient, node-&gt;front-&gt;exponent);</span><br><span class="line">    term-&gt;next = last;</span><br><span class="line">    last-&gt;front = term;</span><br><span class="line">    head = term;</span><br><span class="line">    last = term;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">                                              <span class="comment">//calc.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;calc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;polynomial.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">addOrSub</span><span class="params">(Polynomial &amp;a, Polynomial &amp;b, <span class="type">bool</span> add)</span> </span>&#123;</span><br><span class="line">  Polynomial res;</span><br><span class="line">  Term *na = a.<span class="built_in">getHead</span>(), *nb = b.<span class="built_in">getHead</span>(), *ta = a.<span class="built_in">getTail</span>(),</span><br><span class="line">       *tb = b.<span class="built_in">getTail</span>();</span><br><span class="line">  <span class="keyword">for</span> (; na != ta &amp;&amp; nb != tb;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (na-&gt;exponent &gt; nb-&gt;exponent)</span><br><span class="line">      res.<span class="built_in">put</span>(na-&gt;coefficient, na-&gt;exponent), na = na-&gt;next;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (na-&gt;exponent &lt; nb-&gt;exponent)</span><br><span class="line">      res.<span class="built_in">put</span>(add ? nb-&gt;coefficient : -nb-&gt;coefficient, nb-&gt;exponent),</span><br><span class="line">          nb = nb-&gt;next;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">double</span> c =</span><br><span class="line">          na-&gt;coefficient + (add ? nb-&gt;coefficient : -nb-&gt;coefficient);</span><br><span class="line">      <span class="keyword">if</span> (c &lt;= <span class="number">-0.0000000005</span> || c &gt; <span class="number">0.0000000005</span>)</span><br><span class="line">        res.<span class="built_in">put</span>(c, na-&gt;exponent);</span><br><span class="line">      na = na-&gt;next, nb = nb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (na != ta) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; na != ta;) &#123;</span><br><span class="line">      res.<span class="built_in">put</span>(na-&gt;coefficient, na-&gt;exponent);</span><br><span class="line">      na = na-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (nb != tb) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; nb != tb;) &#123;</span><br><span class="line">      res.<span class="built_in">put</span>(add ? nb-&gt;coefficient : -nb-&gt;coefficient, nb-&gt;exponent);</span><br><span class="line">      nb = nb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">mul</span><span class="params">(Polynomial &amp;a, Polynomial &amp;b)</span> </span>&#123;</span><br><span class="line">  Polynomial res;</span><br><span class="line">  <span class="keyword">for</span> (Term *na = a.<span class="built_in">getHead</span>(), *ta = a.<span class="built_in">getTail</span>(), *tb = b.<span class="built_in">getTail</span>(); na != ta;</span><br><span class="line">       na = na-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Term *nb = b.<span class="built_in">getHead</span>(); nb != tb; nb = nb-&gt;next) &#123;</span><br><span class="line">      res.<span class="built_in">update</span>(na-&gt;coefficient * nb-&gt;coefficient,</span><br><span class="line">                 na-&gt;exponent + nb-&gt;exponent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="built_in">normalize</span>();</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">div</span><span class="params">(Polynomial a, Polynomial &amp;b)</span> </span>&#123;</span><br><span class="line">  Term *c = a.<span class="built_in">getHead</span>(), *d = b.<span class="built_in">getHead</span>(), *ta = a.<span class="built_in">getTail</span>(), *tb = b.<span class="built_in">getTail</span>();</span><br><span class="line">  Polynomial res;</span><br><span class="line">  <span class="keyword">while</span> (c-&gt;exponent &gt;= d-&gt;exponent) &#123;</span><br><span class="line">    Term t = &#123;c-&gt;coefficient / d-&gt;coefficient, c-&gt;exponent - d-&gt;exponent&#125;;</span><br><span class="line">    res.<span class="built_in">put</span>(t.coefficient, t.exponent);</span><br><span class="line">    <span class="keyword">for</span> (Term *node = c, *term = d; node != ta &amp;&amp; term != tb;) &#123;</span><br><span class="line">      <span class="type">int</span> e = term-&gt;exponent + t.exponent;</span><br><span class="line">      <span class="keyword">if</span> (node-&gt;exponent &gt; e)</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;exponent &lt; e)</span><br><span class="line">        term = term-&gt;next;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        node-&gt;coefficient -= t.coefficient * term-&gt;coefficient,</span><br><span class="line">            node = node-&gt;next, term = term-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">normalize</span>();</span><br><span class="line">    c = a.<span class="built_in">getHead</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">ccalc</span><span class="params">(Polynomial &amp;a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  Term *t = a.<span class="built_in">getTail</span>();</span><br><span class="line">  Polynomial res;</span><br><span class="line">  <span class="keyword">for</span> (Term *node = a.<span class="built_in">getHead</span>(); node != t; node = node-&gt;next) &#123;</span><br><span class="line">    <span class="type">double</span> c = node-&gt;coefficient;</span><br><span class="line">    <span class="type">int</span> e = node-&gt;exponent;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = e + <span class="number">1</span>; i &lt;= e + n; ++i) &#123;</span><br><span class="line">      c = c / i;</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">put</span>(c, e + n);</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="built_in">normalize</span>();</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">cdiff</span><span class="params">(Polynomial &amp;a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  Term *t = a.<span class="built_in">getTail</span>();</span><br><span class="line">  Polynomial res;</span><br><span class="line">  <span class="keyword">for</span> (Term *node = a.<span class="built_in">getHead</span>(); node != t; node = node-&gt;next) &#123;</span><br><span class="line">    <span class="type">double</span> c = node-&gt;coefficient;</span><br><span class="line">    <span class="type">int</span> e = node-&gt;exponent;</span><br><span class="line">    <span class="keyword">if</span> (e &gt; <span class="number">0</span> &amp;&amp; e - n &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = e; i &gt; e - n; --i) &#123;</span><br><span class="line">        c = c * i;</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">put</span>(c,e - n);</span><br><span class="line">  &#125; </span><br><span class="line">  res.<span class="built_in">normalize</span>();</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心代码如上所示。留存作纪念。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;什么是一元稀疏多项式？&lt;/p&gt;
&lt;p&gt;是指只有一个未知数，且多项式中非零系数项的数量远少于总项数的多项式。其一般形式可以表示为：P(x) = a&lt;em&gt;nx^n + a&lt;/em&gt;{n-1}x^{n-1} + … + a_1x + a_0，其中n为多</summary>
      
    
    
    
    <category term="code" scheme="https://qaqan.cn/categories/code/"/>
    
    
  </entry>
  
  <entry>
    <title>再看蛙池和去北京</title>
    <link href="https://qaqan.cn/2024/12/24/%E5%86%8D%E7%9C%8B%E8%9B%99%E6%B1%A0%E5%92%8C%E5%8E%BB%E5%8C%97%E4%BA%AC/"/>
    <id>https://qaqan.cn/2024/12/24/%E5%86%8D%E7%9C%8B%E8%9B%99%E6%B1%A0%E5%92%8C%E5%8E%BB%E5%8C%97%E4%BA%AC/</id>
    <published>2024-12-23T16:35:21.000Z</published>
    <updated>2025-07-30T10:41:10.805Z</updated>
    
    <content type="html"><![CDATA[<p>好久没再写博客，从每天都一样的日子里挑出来有印象的几天确实很不容易。更多的时候虽然也有趣事发生，但经历之后发现无太大写的必要。今晚完成了数据结构的答辩，有心情坐下来写一写。<span id="more"></span></p><p><img src="/images/wachi_1.jpg" alt="wachi_1" loading="lazy"></p><p><em>买到了蛙池的冬季巡演</em></p><p>我喜欢蛙池，虽然一开始喜欢的理由是那么潦草：不过是因为主唱金依依像中学时代喜欢过的一个同学。我喜欢她们身上刺眼的生命力。好在时间过去，我仍然继续喜欢这支乐队。他们至少有一支歌是写给我的。</p><p><img src="/images/wachi_2.jpg" alt="wachi_2" loading="lazy"></p><p><em>特别羞涩地签名和合照</em></p><p>然后就和朋友去了北京。</p><p>我也喜欢北京的色彩。在故宫远眺的时候也希望自己是皇帝。吃喝乏味可陈，对我来说。</p><p><img src="/images/BAITA.jpg" alt="baita" loading="lazy"></p><p><em>拍到了白塔，哪吒乐队的一张专辑封面。</em></p><p>发觉听过的很多乐队名、歌词都其来有自，就像后海大鲨鱼，哪吒，赵雷，新裤子。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;好久没再写博客，从每天都一样的日子里挑出来有印象的几天确实很不容易。更多的时候虽然也有趣事发生，但经历之后发现无太大写的必要。今晚完成了数据结构的答辩，有心情坐下来写一写。</summary>
    
    
    
    <category term="live" scheme="https://qaqan.cn/categories/live/"/>
    
    
    <category term="摇滚乐" scheme="https://qaqan.cn/tags/%E6%91%87%E6%BB%9A%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>数据结构讲义</title>
    <link href="https://qaqan.cn/2024/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%B2%E4%B9%89/"/>
    <id>https://qaqan.cn/2024/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%B2%E4%B9%89/</id>
    <published>2024-10-14T09:54:40.000Z</published>
    <updated>2025-07-30T10:40:59.910Z</updated>
    
    <content type="html"><![CDATA[<h1>基本概念</h1><ul><li>空间使用<br>函数PrintN，使得传入一个正整数为N的参数后，打印从1到N的全部正整数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：循环实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintN_1</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=N; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：递归实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintN</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (N)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintN(N - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>算法效率<br>多项式 f(x) = a0 + a1*x^1 +… +an * x^n</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p += (a[i] * <span class="built_in">pow</span>(x, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> p = a[n];</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        p = a[i - <span class="number">1</span>] + x * p;  <span class="comment">// f(x) = a0+ x(a1+x(...(an-1 + x(an))...))</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计时<br>CLK_TCK 为常数，机器始终每秒所走的打点数 Use CLOCKS_PER_SEC instead of CLK_TCK on mac<br>include &lt;time.h&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10 <span class="comment">// 9阶多项式的最大项数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> start, stop;  <span class="comment">//clock()返回的变量类型是 clock_t</span></span><br><span class="line"><span class="type">double</span> duration;  <span class="comment">//秒</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> a[MAXN];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;MAXN; i++) a[i] = (<span class="type">double</span>)i;  <span class="comment">// 假定每一项系数就是i</span></span><br><span class="line"></span><br><span class="line">start = clock();</span><br><span class="line">f1(MAXN<span class="number">-1</span>, a, <span class="number">1.1</span>); <span class="comment">// 假定 x=1.1</span></span><br><span class="line">stop = clock();</span><br><span class="line">duration = (<span class="type">double</span>)(stop -  start)/CLOCKS_PER_SEC; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ticks1 = %f\n&quot;</span>, (<span class="type">double</span>)(stop -  start));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;duration1 = %6.2e\n&quot;</span>, duration);</span><br><span class="line"></span><br><span class="line">start = clock();</span><br><span class="line">f2(MAXN<span class="number">-1</span>, a, <span class="number">1.1</span>); <span class="comment">// 假定 x=1.1</span></span><br><span class="line">stop = clock();</span><br><span class="line">duration = (<span class="type">double</span>)(stop -  start)/CLOCKS_PER_SEC;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ticks2 = %f\n&quot;</span>, (<span class="type">double</span>)(stop -  start));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;duration2 = %6.2e\n&quot;</span>, duration);  <span class="comment">// 要占6位，小数点后2位，以e指数的形式输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p += (a[i] * <span class="built_in">pow</span>(x, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> p = a[n];</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        p = a[i - <span class="number">1</span>] + x * p;  <span class="comment">// f(x) = a0+ x(a1+x(...(an-1 + x(an))...))</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>抽象数据类型 Abstract Data Type</h1><p>数据类型，包含：数据对象集、数据集合相关联操作集。</p><p>抽象指，描述数据类型的方法不依赖于具体实现。 与存放数据的机器、物理结、编程语言构等无关。</p><ul><li>类型名称：矩阵</li><li>数据对象集：M*N</li><li>操作集：…</li></ul><h1>算法</h1><p>空间复杂度S(n)<br>时间复杂度T(n)<br>多项式算法一：<br>(1+2+3+…+n) = (n^2 + n) /2<br>T(n) = C1n^2 + c2n<br>方法二： T(n) = Cn</p><p>最坏情况负责度<br>平均复杂度</p><p>复杂度渐进表示<br>上界：T(n) = O(f(n)), 存在T(n) &lt;= Cf(n)<br>下界： T(n) = Omega(g(n))， 存在T(n) &gt;= Cg(n)</p><h1>实例： 最大子列和问题</h1><h3 id="算法一：">算法一：</h3><p>举例{1,2,3,4}<br>sum = 1<br>sum = 1 + 2<br>sum = 1 + 2 + 3<br>sum = 1 + 2 + 3 + 4<br>sum = 2<br>sum = 2 + 3<br>sum = 2 + 3 + 4<br>sum = 3<br>sum  = 3 + 4<br>sum = 4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MaxSubseqSum1</span><span class="params">( <span class="type">int</span> A[], <span class="type">int</span> N )</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="type">int</span> ThisSum, MaxSum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i, j, k;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; N; i++ ) </span><br><span class="line">    &#123; </span><br><span class="line"><span class="keyword">for</span>( j = i; j &lt; N; j++ ) </span><br><span class="line">        &#123; </span><br><span class="line">ThisSum = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>( k = i; k &lt;= j; k++ )</span><br><span class="line">ThisSum += A[k];</span><br><span class="line"><span class="keyword">if</span>( ThisSum &gt; MaxSum ) </span><br><span class="line">MaxSum = ThisSum; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T(N) =  O(N^3)</p><h3 id="算法二-去掉K这个循环">算法二, 去掉K这个循环</h3><p>举例{1,2,3,4}<br>sum = 1<br>sum = sum_previous + 2<br>sum = sum_previous + 3<br>sum = sum_previous + 4<br>sum = 2<br>sum = sum_previous + 3<br>sum = sum_previous + 4<br>sum = 3<br>sum = sum_previous + 4<br>sum = 4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MaxSubseqSum2</span><span class="params">( <span class="type">int</span> A[], <span class="type">int</span> N )</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="type">int</span> ThisSum, MaxSum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; N; i++ ) </span><br><span class="line">    &#123;</span><br><span class="line">ThisSum = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>( j = i; j &lt; N; j++ ) </span><br><span class="line">&#123; </span><br><span class="line">ThisSum += A[j];</span><br><span class="line">            <span class="keyword">if</span>( ThisSum &gt; MaxSum ) </span><br><span class="line">MaxSum = ThisSum; </span><br><span class="line">&#125; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>T(N) =  O(N^2)</p><h3 id="算法三：-分而治之">算法三： <strong>分而治之</strong></h3><p>T(N) = O(NlogN)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Max3</span><span class="params">( <span class="type">int</span> A, <span class="type">int</span> B, <span class="type">int</span> C )</span></span><br><span class="line">&#123; <span class="comment">/* 返回3个整数中的最大值 */</span></span><br><span class="line">    <span class="keyword">return</span> A &gt; B ? A &gt; C ? A : C : B &gt; C ? B : C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">DivideAndConquer</span><span class="params">( <span class="type">int</span> List[], <span class="type">int</span> left, <span class="type">int</span> right )</span></span><br><span class="line">&#123; <span class="comment">/* 分治法求List[left]到List[right]的最大子列和 */</span></span><br><span class="line">    <span class="type">int</span> MaxLeftSum, MaxRightSum; <span class="comment">/* 存放左右子问题的解 */</span></span><br><span class="line">    <span class="type">int</span> MaxLeftBorderSum, MaxRightBorderSum; <span class="comment">/*存放跨分界线的结果*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> LeftBorderSum, RightBorderSum;</span><br><span class="line">    <span class="type">int</span> center, i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( left == right )  </span><br><span class="line">    &#123; <span class="comment">/* 递归的终止条件，子列只有1个数字 */</span></span><br><span class="line">        <span class="keyword">if</span>( List[left] &gt; <span class="number">0</span> ) </span><br><span class="line">        &#123; </span><br><span class="line">        <span class="comment">// printf(&quot;List[left]=%d\n&quot;, List[left]);</span></span><br><span class="line">        <span class="keyword">return</span> List[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 下面是&quot;分&quot;的过程 */</span></span><br><span class="line">    <span class="comment">// printf(&quot;left=%d\n&quot;, left);</span></span><br><span class="line">    <span class="comment">// printf(&quot;right=%d\n&quot;, right);</span></span><br><span class="line">    center = ( left + right ) / <span class="number">2</span>; <span class="comment">/* 找到中分点 */</span></span><br><span class="line">    <span class="comment">// printf(&quot;center=%d\n&quot;, center);</span></span><br><span class="line">    <span class="comment">/* 递归求得两边子列的最大和 */</span></span><br><span class="line">    MaxLeftSum = DivideAndConquer( List, left, center );</span><br><span class="line">    <span class="comment">// printf(&quot;MaxLeftSum=%d\n&quot;, MaxLeftSum);</span></span><br><span class="line">    MaxRightSum = DivideAndConquer( List, center+<span class="number">1</span>, right );</span><br><span class="line">    <span class="comment">// printf(&quot;MaxRightSum=%d\n&quot;, MaxRightSum);</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 下面求跨分界线的最大子列和 */</span></span><br><span class="line">    MaxLeftBorderSum = <span class="number">0</span>; LeftBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( i=center; i&gt;=left; i-- ) </span><br><span class="line">    &#123; <span class="comment">/* 从中线向左扫描 */</span></span><br><span class="line">        LeftBorderSum += List[i];</span><br><span class="line">        <span class="comment">// printf(&quot;LeftBorderSum=%d\n&quot;, LeftBorderSum);</span></span><br><span class="line">        <span class="keyword">if</span>( LeftBorderSum &gt; MaxLeftBorderSum )</span><br><span class="line">        &#123;</span><br><span class="line">            MaxLeftBorderSum = LeftBorderSum;</span><br><span class="line">            <span class="comment">// printf(&quot;MaxLeftBorderSum=%d\n&quot;, MaxLeftBorderSum);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/* 左边扫描结束 */</span></span><br><span class="line"> </span><br><span class="line">    MaxRightBorderSum = <span class="number">0</span>; RightBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( i=center+<span class="number">1</span>; i&lt;=right; i++ ) </span><br><span class="line">    &#123; <span class="comment">/* 从中线向右扫描 */</span></span><br><span class="line">        RightBorderSum += List[i];</span><br><span class="line">        <span class="comment">// printf(&quot;RightBorderSum=%d\n&quot;, RightBorderSum);</span></span><br><span class="line">        <span class="keyword">if</span>( RightBorderSum &gt; MaxRightBorderSum )</span><br><span class="line">        &#123;</span><br><span class="line">            MaxRightBorderSum = RightBorderSum;</span><br><span class="line">            <span class="comment">// printf(&quot;MaxRightBorderSum=%d\n&quot;, MaxRightBorderSum);</span></span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125; <span class="comment">/* 右边扫描结束 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 下面返回&quot;治&quot;的结果 */</span></span><br><span class="line">    <span class="type">int</span> Max = Max3( MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);</span><br><span class="line">    <span class="comment">// printf(&quot;Max=%d\n&quot;, Max);</span></span><br><span class="line">    <span class="keyword">return</span> Max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">MaxSubseqSum3</span><span class="params">( <span class="type">int</span> List[], <span class="type">int</span> N )</span></span><br><span class="line">&#123; <span class="comment">/* 保持与前2种算法相同的函数接口 */</span></span><br><span class="line">    <span class="keyword">return</span> DivideAndConquer( List, <span class="number">0</span>, N<span class="number">-1</span> );</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="算法四：-在线处理">算法四： <strong>在线处理</strong></h3><p>每一个数据进行即时处理，在任何一个地方输入种植，都给出当前的解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MaxSubseqSum4</span><span class="params">( <span class="type">int</span> A[], <span class="type">int</span> N )</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="type">int</span> ThisSum, MaxSum;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">ThisSum = MaxSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; N; i++ ) &#123;</span><br><span class="line">ThisSum += A[i]; <span class="comment">/* 向右累加 */</span> </span><br><span class="line"><span class="keyword">if</span>( ThisSum &gt; MaxSum )</span><br><span class="line">MaxSum = ThisSum; <span class="comment">/* 发现更大和则更新当前结果 */</span> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( ThisSum &lt; <span class="number">0</span> ) <span class="comment">/* 如果当前子列和为负 */</span></span><br><span class="line">ThisSum = <span class="number">0</span>; <span class="comment">/* 则不可能使后面的部分和增大，抛弃之 */</span> &#125;</span><br><span class="line"><span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>线性结构</h1><p>一元多项式</p><p>$$f(x) = a_0 + a_1x+…+a_nx$$</p><p>方法一：顺序存储结构直接表示<br>a[i]: 系数</p><p>方法二：顺序存储表示非零项<br>用结构数组表示：系数与指数的二元组</p><p>方法三：链表结构存储非零项<br>coef expon link;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">polynomial</span>;</span></span><br><span class="line">truct PolyNode&#123;</span><br><span class="line">   <span class="type">int</span> coef;</span><br><span class="line">   <span class="type">int</span> expon;</span><br><span class="line">   polynomial link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性表-Linear-List">线性表 Linear List</h2><p>同类型数据元素构成有序序列的线性结构。<br>数据对象集：n个元素构成的有序序列<br>操作集：线性表L属于List, 整数表示位置，元素x属于ElementType。操作：</p><ul><li>List MakeEmpty(): 初始化一个空表</li><li>ElementType FindKth(int K, List L); 根据位序K，返回相应元素</li><li>int Find(ElementType x, List L);  在表中查找X第一次出现的位置</li><li>void insert(ElementType X, int i, List L); 插入</li><li>void Delete(int i, List l);  删除</li><li>int length(List L); 返回长度</li></ul><h2 id="线性存储序列的实现">线性存储序列的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">   ElementType Data[MAXSIZE];</span><br><span class="line">   <span class="type">int</span> Last; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">L</span>;</span> </span><br><span class="line">List PtrL;</span><br></pre></td></tr></table></figure><p>访问元素：L.Data[i] or PtrL-&gt;Data[i]<br>线性表的长度:L.Last+1 或 PtrL-&gt;Last+1  (last代表位置，因为从零开始所以是n-1)</p><ul><li>初始化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List <span class="title function_">MakeEmpty</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   List PtrL;</span><br><span class="line">   PtrL = (List )<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode) );  </span><br><span class="line">   PtrL-&gt;Last = <span class="number">-1</span>; <span class="comment">//last若为0 则表示表里有一个元素在0号位置</span></span><br><span class="line">   <span class="keyword">return</span> PtrL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查找</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">( ElementType X, List PtrL )</span> &#123; </span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>( i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!= X ) </span><br><span class="line">      i++;</span><br><span class="line">   <span class="keyword">if</span> (i &gt; PtrL-&gt;Last) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">   <span class="comment">/* 如果没找到，返回-1(因破坏第一个条件而跳出循环) */</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> i; <span class="comment">/* 找到后返回的是存储位置 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平均查找次数(n +1)/2，平均时间性能为 O(n)</p><ul><li>插入<br>第 i (1≤i≤n+1)个位置上插入一个值为X的新元素（其实是插在数组的第i-1个位置，因为数组从0开始标）先移动再插入，n挪到n+1，n-1挪到n, …，i-1挪到i<br>在链表L中的第一个位置插入元素X，如下，MAXSIZE代表链表的size</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">( ElementType X, <span class="type">int</span> i, List PtrL )</span> &#123; </span><br><span class="line">   <span class="type">int</span> j;</span><br><span class="line">   <span class="comment">/* 表空间已满，不能插入*/</span></span><br><span class="line">   <span class="keyword">if</span> ( PtrL-&gt;Last == MAXSIZE<span class="number">-1</span> )</span><br><span class="line">   &#123; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;表满&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*检查插入位置的合法性*/</span></span><br><span class="line">   <span class="keyword">if</span> ( i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last+<span class="number">2</span>) </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;位置不合法&quot;</span>); </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 开始挪位子，从最后的一位last开始直到i-1 */</span></span><br><span class="line">   <span class="keyword">for</span> ( j = PtrL-&gt;Last; j &gt;= i<span class="number">-1</span>; j-- )</span><br><span class="line">      PtrL-&gt;Data[j+<span class="number">1</span>] = PtrL-&gt;Data[j]; </span><br><span class="line">   </span><br><span class="line">   PtrL-&gt;Data[i<span class="number">-1</span>] = X; <span class="comment">/*新元素插入*/</span> </span><br><span class="line">   PtrL-&gt;Last++; <span class="comment">/*Last仍指向最后元素*/</span> </span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平均移动次数为 n /2，<br>/<em>检查插入位置的合法性</em>/ 平均时间性能为 O(n)</p><ul><li>删除<br>删除第i个位置上的元素，i在1到n之间，对应数组下表0到n-1<br>删掉下表为i-1的元素，下标i的元素挪到i-1…</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">( <span class="type">int</span> i, List PtrL )</span> </span><br><span class="line">&#123; </span><br><span class="line">   intj;</span><br><span class="line">   <span class="comment">/*检查空表及删除位置的合法性*/</span></span><br><span class="line">   <span class="keyword">if</span>( i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last+<span class="number">1</span> ) </span><br><span class="line">   &#123; </span><br><span class="line">   <span class="built_in">printf</span> (“不存在第%d个元素”, i );</span><br><span class="line">   <span class="keyword">return</span> ; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*将 ai+1~ an顺序向前移动, 从第i位开始，到last */</span></span><br><span class="line">   <span class="keyword">for</span> ( j = i; j &lt;= PtrL-&gt;Last; j++ ) </span><br><span class="line">      PtrL-&gt;Data[j<span class="number">-1</span>] = PtrL-&gt;Data[j];</span><br><span class="line">      </span><br><span class="line">   PtrL-&gt;Last--; <span class="comment">/*Last仍指向最后元素*/</span></span><br><span class="line">   <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平均移动次数为 (n-1) /2<br>平均时间性能为 O(n)</p><h2 id="链式存储的实现">链式存储的实现</h2><p>一个线性表用数组存储的时候，相邻的元素不仅逻辑上不仅逻辑上相邻，物理上也是相邻的。而链表通过链连接，建立数据元素的逻辑关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ElementType Data;</span><br><span class="line">   List Next; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> <span class="title">L</span>;</span> </span><br><span class="line">List PtrL;</span><br></pre></td></tr></table></figure><ul><li>求表长<br>用临时指针p指向链表头Ptrl，然后遍历，直到null</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span> <span class="params">( List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">   List p = PtrL;  <span class="comment">/* p指向表的第一个结点*/</span></span><br><span class="line">   <span class="type">int</span> j=<span class="number">0</span>; </span><br><span class="line">   <span class="keyword">while</span> ( p ) </span><br><span class="line">   &#123;</span><br><span class="line">      p = p-&gt;Next; </span><br><span class="line">      j++;  <span class="comment">/* 当前p指向的是第 j 个结点*/</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> j; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查找</li></ul><ol><li>按序号查找 根据位序K，返回相应元素 FindKth(int K, List L)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List <span class="title function_">FindKth</span><span class="params">( <span class="type">int</span> K, List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">   List p = PtrL;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">1</span>;  <span class="comment">// i代表第几给元素。因为一开始p指向第一个元素，所以i=1</span></span><br><span class="line">   <span class="keyword">while</span> (p !=<span class="literal">NULL</span> &amp;&amp; i &lt; K )</span><br><span class="line">   &#123;</span><br><span class="line">      p = p-&gt;Next;</span><br><span class="line">      i++; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( i == K ) <span class="comment">/* 找到第K个，返回指针 */</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">/* 没找到第K个，循环因为 p=NULL 而退出 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>按值查找：Find(ElementType x, List L)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List <span class="title function_">Find</span><span class="params">( ElementType X, List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">   List p = PtrL;</span><br><span class="line">   <span class="keyword">while</span> ( p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;Data != X ) <span class="comment">// 条件1表不空，条件2没找到X，就继续</span></span><br><span class="line">      p = p-&gt;Next;</span><br><span class="line">   <span class="keyword">return</span> p; <span class="comment">//找到了：返回节点p。没找到返回p = NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入<br>在第 i-1 (1≤i≤n+1) 个结点后插入一个值为X的新结点</li></ul><ol><li>先构造一个新结点，用s指向; mallo</li><li>再找到链表的第 i-1个结点，用p指向;</li><li>然后修改指针，插入结点 ( p之后插入新结点是 s)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s-&gt; next = p -&gt; next;</span><br><span class="line">p -&gt; next = s</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List <span class="title function_">Insert</span><span class="params">( ElementType X, <span class="type">int</span> i, List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">   List p, s; </span><br><span class="line">   <span class="keyword">if</span> ( i == <span class="number">1</span> )   <span class="comment">/* 新结点插入在表头 */</span></span><br><span class="line">   &#123;</span><br><span class="line">      s = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));  <span class="comment">/*申请、填装结点s */</span></span><br><span class="line">      s-&gt;Data = X;</span><br><span class="line">      s-&gt;Next = PtrL; </span><br><span class="line">      <span class="keyword">return</span> s;  <span class="comment">// s成为新的head，返回出去</span></span><br><span class="line">   &#125;</span><br><span class="line">   p = FindKth( i<span class="number">-1</span>, PtrL );  <span class="comment">/* 查找第i-1个结点 */</span></span><br><span class="line">   <span class="keyword">if</span> ( p == <span class="literal">NULL</span> )  </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;参数i错&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">   &#123;</span><br><span class="line">      s = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode)); <span class="comment">/*申请、填装结点*/</span> </span><br><span class="line">      s-&gt;Data = X;</span><br><span class="line">      s-&gt;Next = p-&gt;Next; <span class="comment">/*新结点插入在第i-1个结点的后面*/</span> </span><br><span class="line">      p-&gt;Next = s;</span><br><span class="line">      <span class="keyword">return</span> PtrL;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除<br>删除链表的第 i (1≤i≤n) 个位置上的节点</li></ul><ol><li>先找到链表的第 i-1个结点，用p指向;</li><li>再用指针s指向要被删除的结点(p的下一个结点);</li><li>然后修改指针，删除s所指结点;  <code>p-&gt;next = s-&gt;next</code></li><li>最后释放s所指结点的空间。<br>实现</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List <span class="title function_">Delete</span><span class="params">( <span class="type">int</span> i, List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">   List p, s;</span><br><span class="line">   <span class="keyword">if</span> ( i == <span class="number">1</span> ) </span><br><span class="line">   &#123; <span class="comment">/* 若要删除的是表的第一个结点 */</span></span><br><span class="line">      s = PtrL; <span class="comment">/*s指向第1个结点*/</span> </span><br><span class="line">      <span class="keyword">if</span> (PtrL!=<span class="literal">NULL</span>) </span><br><span class="line">         PtrL = PtrL-&gt;Next; <span class="comment">/*从链表中删除*/</span></span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 如果本身就是空链表，return NULL</span></span><br><span class="line">      <span class="built_in">free</span>(s);</span><br><span class="line">      <span class="keyword">return</span> PtrL;</span><br><span class="line">   &#125;</span><br><span class="line">   p = FindKth( i<span class="number">-1</span>, PtrL ); <span class="comment">/*查找第i-1个结点*/</span>   </span><br><span class="line">   <span class="keyword">if</span> ( p == <span class="literal">NULL</span> ) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(“第%d个结点不存在”, i<span class="number">-1</span>); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> ( p-&gt;Next == <span class="literal">NULL</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(“第%d个结点不存在”, i); </span><br><span class="line">   &#125;<span class="keyword">else</span> </span><br><span class="line">   &#123;</span><br><span class="line">      s = p-&gt;Next;   <span class="comment">/*s指向第i个结点*/</span></span><br><span class="line">      p-&gt;Next = s-&gt;Next;   <span class="comment">/*从链表中删除*/</span></span><br><span class="line">      <span class="built_in">free</span>(s);  <span class="comment">/*释放被删除结点 */</span></span><br><span class="line">      <span class="keyword">return</span> PtrL;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>广义表  Generalized List</h1><p>二元多项式<br>可以将上述二元多项式看成关于x 的一元多项式<br>矩阵可以用二维数组表示，但二维数组表示有两个缺陷：</p><ol><li>一是数组的大小需要事先确定</li><li>对于“稀疏矩阵 ”，将造成大量的存储空间浪费。<br>采用一种典型的多重链表——十字链表来存储稀疏矩阵</li></ol><ul><li>只存储矩阵非0元素项 结点的数据域:行坐标Row、列坐标Col、数值Value</li><li>每个结点通过两个指针域，把同行、同列串起来<ul><li>行指针(或称为向右指针)Right</li><li>列指针(或称为向下指针)Down</li></ul></li></ul><p>Term 代表非0项<br>特殊Term A 代表4行5列，7个非零项</p><h1>堆栈 Stack</h1><p>具有一定操作约束的线性表，只在一端(栈顶，Top)做 插入、删除<br>操作集:长度为MaxSize的堆栈S 属于 Stack，堆栈元素item 属于 ElementType</p><ol><li>Stack CreateStack( int MaxSize ): 生成空堆栈，其最大长度为MaxSize;</li><li>int IsFull( Stack S, int MaxSize ):判断堆栈S是否已满;</li><li>void Push( Stack S, ElementType item ):将元素item压入堆栈;</li><li>int IsEmpty ( Stack S ):判断堆栈S是否为空;</li><li>ElementType Pop( Stack S ):删除并返回栈顶元素;</li></ol><h2 id="栈的顺序存储实现">栈的顺序存储实现</h2><p>栈的顺序存储结构通常由一个一维数组和一个记录.栈顶元素位置的变量组成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize <span class="string">&lt;储存数据元素的最大个数&gt;</span> </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span>  <span class="comment">//结构指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];  <span class="comment">//数组</span></span><br><span class="line">    <span class="type">int</span> Top; <span class="comment">// 栈顶位置的数组下标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>入栈 Push</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">( Stack PtrS, ElementType item )</span>  <span class="comment">// stack这个类型的指针</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( PtrS-&gt;Top == MaxSize<span class="number">-1</span> ) <span class="comment">// 判断满不满。从 0 到 MaxSize-1</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(“堆栈满”); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        PtrS-&gt;Data[++(PtrS-&gt;Top)] = item; </span><br><span class="line">        <span class="comment">/* 相当于：</span></span><br><span class="line"><span class="comment">        (PtrS-&gt;Top)++;</span></span><br><span class="line"><span class="comment">        PtrS-&gt;Data[PtrS-&gt;Top] = item;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>出栈 Top</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">Pop</span><span class="params">( Stack PtrS )</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( PtrS-&gt;Top == <span class="number">-1</span> ) </span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">printf</span>(“堆栈空”);</span><br><span class="line">         <span class="keyword">return</span> ERROR;  <span class="comment">//ERROR是ElementType的特殊值，标志错误</span></span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ( PtrS-&gt;Data[(PtrS-&gt;Top)--] ); <span class="comment">// return 出下标为top的这个值，同时Top-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[例] 请用一个数组实现两个堆栈，要求最大地利用数组空间，使 数组只要有空间入栈操作就可以成功。<br>【分析】 一种比较聪明的方法是使这两个栈分别从数组的两头开始 向中间生长;当两个栈的栈顶指针相遇时，表示两个栈都满了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize <span class="string">&lt;存储数据元素的最大个数&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DStack</span> &#123;</span></span><br><span class="line">    ElementType Data[MaxSize]; </span><br><span class="line">    <span class="type">int</span> Top1; <span class="comment">/* 堆栈1的栈顶指针 */</span> </span><br><span class="line">    <span class="type">int</span> Top2; <span class="comment">/* 堆栈2的栈顶指针 */</span></span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line">S.Top1 = <span class="number">-1</span>; <span class="comment">// 左边这个设为空</span></span><br><span class="line">S.Top2 = MaxSize; <span class="comment">// 右边设为空（已经超出了MaxSize -1)</span></span><br></pre></td></tr></table></figure><p>入栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">( <span class="keyword">struct</span> DStack *PtrS, ElementType item, <span class="type">int</span> Tag )</span> </span><br><span class="line">&#123; <span class="comment">/* Tag作为区分两个堆栈的标志，取值为1和2 */</span></span><br><span class="line">    <span class="keyword">if</span> ( PtrS-&gt;Top2 – PtrS-&gt;Top1 == <span class="number">1</span>) <span class="comment">/* 堆栈满, 两个指针相邻啦 */</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(“堆栈满”); </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( Tag == <span class="number">1</span> ) <span class="comment">/* 对第一个堆栈操作 */</span></span><br><span class="line">        PtrS-&gt;Data[++(PtrS-&gt;Top1)] = item;  <span class="comment">// 放在第一个元素后面一位</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 对第二个堆栈操作 */</span> </span><br><span class="line">        PtrS-&gt;Data[--(PtrS-&gt;Top2)] = item;  <span class="comment">// 放在最后一个元素的前面一位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">Pop</span><span class="params">( <span class="keyword">struct</span> DStack *PtrS, <span class="type">int</span> Tag )</span> </span><br><span class="line">&#123; <span class="comment">/* Tag区分两个堆栈*/</span></span><br><span class="line">    <span class="keyword">if</span>(Tag==<span class="number">1</span>) <span class="comment">/*对第一个堆栈操作 */</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> ( PtrS-&gt;Top1 == <span class="number">-1</span> )  <span class="comment">/*堆栈1空 */</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="built_in">printf</span>(“堆栈<span class="number">1</span>空”); </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> PtrS-&gt;Data[(PtrS-&gt;Top1)--]; <span class="comment">// 先抛出再对top-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="comment">/* 对第二个堆栈操作 */</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> ( PtrS-&gt;Top2 == MaxSize )  <span class="comment">/*堆栈2空 */</span></span><br><span class="line">        &#123;        </span><br><span class="line">            <span class="built_in">printf</span>(“堆栈<span class="number">2</span>空”); </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> PtrS-&gt;Data[(PtrS-&gt;Top2)++]; <span class="comment">// 先抛出再对top+1</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆栈的链式存储实">堆栈的链式存储实</h2><p>栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删 除操作只能在链栈的栈顶进行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Next</span>;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化(建立空栈)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack <span class="title function_">CreateStack</span><span class="params">()</span></span><br><span class="line">&#123; <span class="comment">/* 构建一个堆栈的头结点，返回指针 */</span></span><br><span class="line">    Stack S;</span><br><span class="line">    S =(Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> SNode)); </span><br><span class="line">    S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断堆栈S是否为空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(Stack S)</span> <span class="comment">/*判断堆栈S是否为空，若为空函数返回1，否则返回0 */</span></span><br><span class="line">&#123; </span><br><span class="line">   <span class="keyword">return</span> ( S-&gt;Next == <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>入栈 Push</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">( ElementType item, Stack S)</span> <span class="comment">/* 将元素item压入堆栈S */</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">TmpCell</span>;</span></span><br><span class="line">    TmpCell=(<span class="keyword">struct</span> SNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> SNode))</span><br><span class="line">    TmpCell-&gt;Element = item;</span><br><span class="line">    TmpCell-&gt;Next = S-&gt;Next;  <span class="comment">// 插到头结点的后面</span></span><br><span class="line">    S-&gt;Next = TmpCell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>出栈 Top</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">Pop</span><span class="params">(Stack S)</span>  <span class="comment">/* 删除并返回堆栈S的栈顶元素 */</span></span><br><span class="line">&#123; </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">FirstCell</span>;</span></span><br><span class="line">   ElementType TopElem;</span><br><span class="line">   <span class="keyword">if</span>( IsEmpty( S ) ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“堆栈空”); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        FirstCell = S-&gt;Next;</span><br><span class="line">        S-&gt;Next = FirstCell-&gt;Next; </span><br><span class="line">        TopElem = FirstCell -&gt;Element; <span class="comment">// 获得被删除的这个值,return出去</span></span><br><span class="line">        <span class="built_in">free</span>(FirstCell);</span><br><span class="line">        <span class="keyword">return</span> TopElem;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用-表达式求值">应用:表达式求值</h2><ol><li><p>运算数相对顺序不变</p></li><li><p>运算符号顺序发生改变: 需要存储“等待中”的运算符号,要将当前运算符号与“等待中”的最后一个运算符号比较</p><p>如果最后一个符号的优先级比较高,则出栈</p><p>如果最后一个符号的优先级更低,则等待</p></li></ol><p>括号怎么办?<br>左括号(优先级比乘号*高.但左括号(在堆栈中优先级就降到最低, 左括号(优先级比加号+低.<br>碰到右括号)后,括号内的计算结束,把堆栈内的抛出来,直到遇到左括号(.</p><h1>队列 Queue</h1><p>FIFO<br>操作集:长度为MaxSize的队列Q Î Queue，队列元素item Î ElementType</p><ol><li>Queue CreatQueue( int MaxSize ):生成长度为MaxSize的空队列;</li><li>int IsFullQ( Queue Q, int MaxSize ):判断队列Q是否已满;</li><li>void AddQ( Queue Q, ElementType item ): 将数据元素item插入队列Q中;</li><li>int IsEmptyQ( Queue Q ): 判断队列Q是否为空;</li><li>ElementType DeleteQ( Queue Q ):将队头数据元素从队列中删除并返回。</li></ol><h2 id="队列的顺序存储实现">队列的顺序存储实现</h2><p>一个一维数组,队列头元素位置的变量front, 队列为元素位置的变量rear, 而堆栈由一个一位数组加上一个top.<br>队列的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize <span class="string">&lt;储存数据元素的最大个数&gt;</span> </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    ElementType Data[ MaxSize ]; </span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br></pre></td></tr></table></figure><p>循环队列<br>当front == rear时候, 空<br>rear指向这个队列实际的最后一个元素的位置,front是第一个元素的前一个. 加入一个元素的时候rear + 1, 删除一个元素的时候front + 1<br>使用额外标记 size或者tag<br>仅使用n-1个数组空间</p><ol><li>创建队列</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Queue <span class="title function_">CreateQueue</span><span class="params">(<span class="type">int</span> Maxsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">    Q-&gt;Data = (ElementType)<span class="built_in">malloc</span>(Maxsize * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;Maxsize = Maxsize;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>入队列<br>用求余数函数,实现循环队列 例如 (5+1)%6 = 0, 放在第0位</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AddQ</span><span class="params">( Queue PtrQ, ElementType item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (PtrQ-&gt;rear+<span class="number">1</span>) % MaxSize == PtrQ-&gt;front ) <span class="comment">// front rear相邻</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(“队列满”);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PtrQ-&gt;rear = (PtrQ-&gt;rear+<span class="number">1</span>)% MaxSize; </span><br><span class="line">    PtrQ-&gt;Data[PtrQ-&gt;rear] = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>出队</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">DeleteQ</span> <span class="params">( Queue PtrQ )</span> <span class="comment">// front和rear相同</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( PtrQ-&gt;front == PtrQ-&gt;rear ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(“队列空”);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        PtrQ-&gt;front = (PtrQ-&gt;front+<span class="number">1</span>)% MaxSize; <span class="comment">// front往后移一位指向第一个元素</span></span><br><span class="line">        <span class="keyword">return</span> PtrQ-&gt;Data[PtrQ-&gt;front];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列的链式存储实现">队列的链式存储实现</h2><p>链表结点结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> </span><br><span class="line">    ElementType Data; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链表队列结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">rear</span>;</span> <span class="comment">/* 指向队尾结点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">front</span>;</span> <span class="comment">/* 指向队头结点 */</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span>  </span><br><span class="line">Queue PtrQ;  <span class="comment">// 包含front和rear的这个结构的指针PtrQ</span></span><br></pre></td></tr></table></figure><ol><li>出队</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">DeleteQ</span> <span class="params">( Queue PtrQ )</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">FrontCell</span>;</span></span><br><span class="line">    ElementType FrontElem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( PtrQ-&gt;front == <span class="literal">NULL</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(“队列空”); </span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    FrontCell = PtrQ-&gt;front;  <span class="comment">// 找到队列的头个元素</span></span><br><span class="line">    <span class="keyword">if</span> ( PtrQ-&gt;front == PtrQ-&gt;rear) <span class="comment">/* 若队列只有一个元素 */</span></span><br><span class="line">        PtrQ-&gt;front = PtrQ-&gt;rear = <span class="literal">NULL</span>; <span class="comment">/* 删除后队列置为空 */</span> </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PtrQ-&gt;front = PtrQ-&gt;front-&gt;Next;</span><br><span class="line">    FrontElem = FrontCell-&gt;Data;</span><br><span class="line">    <span class="built_in">free</span>( FrontCell ); <span class="comment">/* 释放被删除结点空间 */</span> </span><br><span class="line">    <span class="keyword">return</span> FrontElem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用-多项式加法运算">应用: 多项式加法运算</h2><p>算法思路:<br>两个指针P1和P2分别指向这两个多项式第一个结点，不断循环:</p><ol><li>P1-&gt;expon==P2-&gt;expon相同: 系数相加，若结果不为0，则作为结果多项式对应项<br>的系数。同时，P1和P2都分别指向下一项;</li><li>P1-&gt;expon&gt;P2-&gt;expon 这时p1大: 将P1的当前项存入结果多项式，并使P1指向下一项;</li><li>P1-&gt;expon<P2->expon 这时p2大: 将P2的当前项存入结果多项式，并使P2指向下一项;</li><li>当某一多项式处理完时，将另一个多项式的所有结点依次复制到结果多项式中去。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> //结构类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> coef; <span class="comment">// 系数</span></span><br><span class="line">    <span class="type">int</span> expon; <span class="comment">// 指数 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">link</span>;</span>  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynomial</span>;</span> </span><br><span class="line">Polynomial P1, P2;  <span class="comment">// p1 p2都是这种结构的指针</span></span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Polynomial <span class="title function_">PolyAdd</span> <span class="params">(Polynomial P1, Polynomial P2)</span> </span><br><span class="line">&#123;</span><br><span class="line">    Polynomial front, rear, temp;  <span class="comment">// 结构多项式的头 尾.</span></span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 临时空结点点作为结果多项式的表头, front rear都指向这个空间点</span></span><br><span class="line">    rear = (Polynomial) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PolyNode)); </span><br><span class="line">    front = rear; <span class="comment">/* 由front 记录结果多项式链表头结点 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( P1 &amp;&amp; P2 ) <span class="comment">/* 当两个多项式都有非零项(都不空)待处理时 */</span> </span><br><span class="line">        <span class="keyword">switch</span> ( Compare(P1-&gt;expon, P2-&gt;expon) ) <span class="comment">// 比较两个指数</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">// p1大</span></span><br><span class="line">                <span class="comment">// 系数和指素接到rear的后面</span></span><br><span class="line">                Attach( P1-&gt;coef, P1-&gt;expon, &amp;rear); </span><br><span class="line">                P1 = P1-&gt;link;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">// p2大</span></span><br><span class="line">                Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear); </span><br><span class="line">                P2 = P2-&gt;link;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//p1 = p2</span></span><br><span class="line">                sum = P1-&gt;coef + P2-&gt;coef;</span><br><span class="line">                <span class="comment">// 判断sum不等于0</span></span><br><span class="line">                <span class="keyword">if</span> ( sum ) Attach(sum, P1-&gt;expon, &amp;rear); </span><br><span class="line">                P1 = P1-&gt;link;</span><br><span class="line">                P2 = P2-&gt;link;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/* 将未处理完的另一个多项式的所有节点依次复制到结果多项式中去 */</span> </span><br><span class="line">    <span class="comment">// p1不空</span></span><br><span class="line">    <span class="keyword">for</span> ( ; P1; P1 = P1-&gt;link ) </span><br><span class="line">        Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">    <span class="comment">// p2 不空</span></span><br><span class="line">    <span class="keyword">for</span> ( ; P2; P2 = P2-&gt;link ) </span><br><span class="line">        Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rear 指向结果多项式的最后一项,现在结束了,把link设为NULL</span></span><br><span class="line">    rear-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 释放临时结点</span></span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;link; <span class="comment">/*令front指向结果多项式第一个非零项 */</span> </span><br><span class="line">    <span class="built_in">free</span>(temp); <span class="comment">/* 释放临时空表头结点 */</span></span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中attach函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入系数和指数,以及最后一个结点的指针位置(指针的指针),于在本函数中需要改变当前结果表达式尾项指针的值,所以函数传递进来的是结点指针的地址，*pRear指向尾项</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">Attach</span><span class="params">( <span class="type">int</span> c, <span class="type">int</span> e, Polynomial *pRear )</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynomial P;</span><br><span class="line">    <span class="comment">/* 申请新结点 */</span> </span><br><span class="line">    P =(Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PolyNode)); </span><br><span class="line">    P-&gt;coef = c; <span class="comment">/* 对新结点赋值 */</span></span><br><span class="line">    P-&gt;expon = e;</span><br><span class="line">    P-&gt;link=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* 将P指向的新结点插入到当前结果表达式尾项的后面 */</span> </span><br><span class="line">    (*pRear)-&gt;link = P;</span><br><span class="line">    *pRear = P; <span class="comment">/* 修改pRear值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>树与树的表示</h1><p>查找 Searching</p><ul><li>静态查找 集合是固定的,没有插入和删除</li><li>动态查找 集合中的记录是动态变化的,可以插入和删除</li></ul><h3 id="静态查找-Sequential-Search">静态查找 Sequential Search</h3><p>结构体:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>&#123;</span></span><br><span class="line">    ElementType Element[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SequentialSearch</span><span class="params">(List tb1, ElementType K)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    tb1-&gt;Element[<span class="number">0</span>] = K; <span class="comment">// 建立哨兵</span></span><br><span class="line">    <span class="keyword">for</span>(i = tb1-&gt;length; tb1-&gt;Element[i] != K; i--); <span class="comment">//从下往上循环直到K</span></span><br><span class="line">    <span class="keyword">return</span> i;  <span class="comment">// 成功返回下标,不成功返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序查找算法的时间复杂度为O(n)</p><h3 id="二分查找-Binary-Search">二分查找 Binary Search</h3><p>函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BinarySearch</span> <span class="params">( StaticTable * Tb1, ElementType K)</span> </span><br><span class="line">&#123; <span class="comment">/*在表Tbl中查找关键字为K的数据元素*/</span></span><br><span class="line">    <span class="type">int</span> left, right, mid, NoFound=<span class="number">-1</span>;</span><br><span class="line">    left = <span class="number">1</span>;</span><br><span class="line">    right = Tb1-&gt;Length; </span><br><span class="line">    <span class="keyword">while</span> ( left &lt;= right ) </span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( K &lt; Tb1-&gt;Element[mid]) right = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( K &gt; Tb1-&gt;Element[mid]) left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid; <span class="comment">/*查找成功，返回数据元素的下标*/</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> NotFound; <span class="comment">/*查找不成功，返回-1*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找算法具有对数的时间复杂度O(logN)<br>判定树:<br>判定树上每个结点需要的查找次数刚好 为该结点所在的层数.<br>n个结点的判定树的深度 为[log2n]+1.</p><h2 id="树-Tree">树 Tree</h2><p>定义:n(n≥0)个结点构成的有限集合<br>子树是不相交的,除了根结点外，每个结点有且仅有一个父结点<br>结点的度(Degree):结点的子树个数<br>树的度:树的所有结点中最大的度数<br>结点的层次(Level):规定根结点在1层， 其它任一结点的层数是其父结点的层数加1。<br>树的深度(Depth):树中所有结点中的最 大层次是这棵树的深度。</p><h3 id="二叉树">二叉树</h3><p>度为2的树,可以为空.若不为空由根节点和左子树和右子树</p><ul><li>一个二叉树第 i 层的最大结点数为:2^(i-1)</li><li>深度为k的二叉树有最大结点总数为: 2^k -1</li><li>对任何非空二叉树T，若$n_0$表示叶结点的个数、$n_2$是度为2的非叶结点个数，那么两者满足关系$n_0 = n_2 +1$<br>证明: 总边数=总节点数-1 (因为根没有向上的边)<br>总边数= n0 + n1 +n2 -1<br>总边数 = 0<em>n0 + 1</em>n1 + 2*n2  (往下看)</li></ul><p>二叉树的存储结构</p><ol><li>顺序存储结构<br>完全二叉树<br>父节点:i/2<br>左子节点: 2i<br>右子节点: 2i+1</li><li>链表存储</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">BinTree</span>;</span> </span><br><span class="line"><span class="keyword">typedef</span> BinTree Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data; </span><br><span class="line">    BinTree Left; </span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历">二叉树的遍历</h3><ol start="2"><li>先序遍历  PreOrder Traversal<br>根节点-&gt;左子树-&gt;右子树</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">PreOrderTraversal</span><span class="params">( BinTree BT )</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>( BT ) <span class="comment">// BT不空</span></span><br><span class="line">     &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“%d”, BT-&gt;Data);</span><br><span class="line">        PreOrderTraversal( BT-&gt;Left );</span><br><span class="line">        PreOrderTraversal( BT-&gt;Right );</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>中序遍历 InOrderT Traversal<br>左子树-&gt;根节点-&gt;右子树</li><li>后序遍历 Post-Order Traversal<br>左子树-&gt;右子树-&gt;根节点</li></ol><p>二叉树的非递归遍历<br>中序遍历的非递归算法实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraversal</span><span class="params">( BinTree BT )</span></span><br><span class="line">&#123;  </span><br><span class="line">    BinTree T=BT;</span><br><span class="line">    Stack S = CreatStack( MaxSize ); <span class="comment">/*创建并初始化堆栈S*/</span> </span><br><span class="line">    <span class="keyword">while</span>( T || !IsEmpty(S) )</span><br><span class="line">    &#123;  <span class="comment">//IsEmpty是判断堆栈空不空</span></span><br><span class="line">        <span class="keyword">while</span>(T)&#123; <span class="comment">/*一直向左并将沿途结点压入堆栈*/</span> \</span><br><span class="line">            Push(S,T);</span><br><span class="line">            T = T-&gt;Left; </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))&#123;</span><br><span class="line">            T = Pop(S); <span class="comment">/*结点弹出堆栈*/</span></span><br><span class="line">            <span class="built_in">printf</span>(“%<span class="number">5</span>d”, T-&gt;Data); <span class="comment">/*(访问)打印结点*/</span> </span><br><span class="line">            T = T-&gt;Right; <span class="comment">/*转向右子树*/</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历">层序遍历</h3><p>队列实现:遍历从根结点开始，首先将根结点入队，然后开始执 行循环:结点出队、访问该结点、其左右儿子入队<br>算法实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrderTraversal</span> <span class="params">( BinTree BT )</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue Q; BinTree T;</span><br><span class="line">    <span class="keyword">if</span> ( !BT ) <span class="keyword">return</span>; <span class="comment">/* 若是空树则直接返回 */</span> </span><br><span class="line">    Q = CreatQueue( MaxSize ); <span class="comment">/*创建并初始化队列Q*/</span> </span><br><span class="line">    AddQ( Q, BT ); <span class="comment">// 把根节点放到队列里去</span></span><br><span class="line">    <span class="keyword">while</span> ( !IsEmptyQ( Q ) ) &#123;</span><br><span class="line">        T = DeleteQ( Q );  <span class="comment">// pop出一个元素,产生的元素赋给 T指针</span></span><br><span class="line">        <span class="built_in">printf</span>(“%d\n”, T-&gt;Data); <span class="comment">/*访问取出队列的结点*/</span> </span><br><span class="line">        <span class="keyword">if</span> ( T-&gt;Left ) AddQ( Q, T-&gt;Left );</span><br><span class="line">        <span class="keyword">if</span> ( T-&gt;Right ) AddQ( Q, T-&gt;Right );</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出二叉树叶子节点">输出二叉树叶子节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrderPrintLeaves</span><span class="params">( BinTree BT )</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( BT ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !BT-&gt;Left &amp;&amp; !BT-&gt;Right ) <span class="comment">// 如果没有左右子树,就打印出来</span></span><br><span class="line">            <span class="built_in">printf</span>(“%d”, BT-&gt;Data ); </span><br><span class="line">        PreOrderPrintLeaves ( BT-&gt;Left ); </span><br><span class="line">        PreOrderPrintLeaves ( BT-&gt;Right );</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树的高度">求二叉树的高度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PostOrderGetHeight</span><span class="params">( BinTree BT )</span> </span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> HL, HR, MaxH;</span><br><span class="line">    <span class="keyword">if</span>( BT ) </span><br><span class="line">    &#123;</span><br><span class="line">        HL = PostOrderGetHeight(BT-&gt;Left); <span class="comment">/*求左子树的深度*/</span> </span><br><span class="line">        HR = PostOrderGetHeight(BT-&gt;Right); <span class="comment">/*求右子树的深度*/</span> </span><br><span class="line">        MaxH = (HL &gt; HR)? HL : HR; <span class="comment">/*取左右子树较大的深度*/</span> </span><br><span class="line">        <span class="keyword">return</span> ( MaxH + <span class="number">1</span> ); <span class="comment">/*返回树的深度*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 空树深度为0 */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序生成二叉树">层序生成二叉树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType; <span class="comment">//假设是int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NoInfo 0;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">BinTree</span>;</span> </span><br><span class="line"><span class="keyword">typedef</span> BinTree Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data; </span><br><span class="line">    BinTree Left; </span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree <span class="title function_">CreateBinTree</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree BT, T;</span><br><span class="line">    Q = CreateQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入第一个检点,即根节点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Data);</span><br><span class="line">    <span class="keyword">if</span> (Data != NoInfo)</span><br><span class="line">    &#123; <span class="comment">// 不为空, 分配根节点单元,并将节点地址入队</span></span><br><span class="line">        BT = (BinTree)mallo(<span class="keyword">sizeof</span>(Struct Tnode));</span><br><span class="line">        BT-&gt;Data = Data;</span><br><span class="line">        Bt-&gt;Left = BT-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">        AddQ(Q, BT);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//若第一个数据0,则返回空树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        T-&gt;DeleteQ(Q);  <span class="comment">//从队列中取出一节点地址</span></span><br><span class="line">        <span class="comment">// 读左孩子</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Data);</span><br><span class="line">        <span class="keyword">if</span>(Data != NoInfo)</span><br><span class="line">            T-&gt;Left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 分配新节点,作为出队节点的左孩子,分配的新节点入队</span></span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;Left = (BinTree)mallo(<span class="keyword">sizeof</span>(Struct Tnode));</span><br><span class="line">            T-&gt;Left-&gt;Data = Data;</span><br><span class="line">            T-&gt;Left-&gt;Left = T-&gt;Left-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">            AddQ(Q, T-&gt;Left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读右孩子</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Data);</span><br><span class="line">        <span class="keyword">if</span>(Data != NoInfo)</span><br><span class="line">            T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 分配新节点,作为出队节点的右孩子,分配的新节点入队</span></span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;Right = (BinTree)mallo(<span class="keyword">sizeof</span>(Struct Tnode));</span><br><span class="line">            T-&gt;Right-&gt;Data = Data;</span><br><span class="line">            T-&gt;Right-&gt;Left = T-&gt;Right-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">            AddQ(Q, T-&gt;Left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// while循环结束</span></span><br><span class="line">    <span class="keyword">return</span> BT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二叉搜索树 Binary Search Tree</h1><ol><li>非空左子树所有键值小于根节点的键值</li><li>非空右子树所有键值大于根节点的键值</li><li>左右子树都是二叉搜索树</li></ol><p>操作的函数:</p><ol><li>Position Find( ElementType X, BinTree BST ):从二叉搜索树BST 中查找元素X，返回其所在结点的地址;</li><li>Position FindMin( BinTree BST ):从二叉搜索树BST中查找并返回 最小元素所在结点的地址;</li><li>Position FindMax( BinTree BST ) :从二叉搜索树BST中查找并返回 最大元素所在结点的地址。</li><li>BinTree Insert( ElementType X, BinTree BST ) 插入</li><li>BinTree Delete( ElementType X, BinTree BST ) 删除</li></ol><h2 id="查找">查找</h2><p>递归实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">Find</span><span class="params">( ElementType X, BinTree BST )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( !BST ) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/*查找失败*/</span> </span><br><span class="line">    <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">        <span class="keyword">return</span> Find( X, BST-&gt;Right ); <span class="comment">/*在右子树中继续查找*/</span></span><br><span class="line">    Else <span class="title function_">if</span><span class="params">( X &lt; BST-&gt;Data )</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">Find</span><span class="params">( X, BST-&gt;Left )</span>; <span class="comment">/*在左子树中继续查找*/</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">/* X == BST-&gt;Data */</span></span><br><span class="line">        <span class="keyword">return</span> BST; <span class="comment">/*查找成功，返回结点的找到结点的地址*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">IterFind</span><span class="params">( ElementType X, BinTree BST )</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>( BST ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">            BST = BST-&gt;Right; <span class="comment">/*向右子树中移动，继续查找*/</span> </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">            BST = BST-&gt;Left; <span class="comment">/*向左子树中移动，继续查找*/</span> </span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* X == BST-&gt;Data */</span></span><br><span class="line">            <span class="keyword">return</span> BST; <span class="comment">/*查找成功，返回结点的找到结点的地址*/</span> </span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/*查找失败*/</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="返回最大值-最小值">返回最大值/最小值</h2><p>最大元素一定在最右分支的端点上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">FindMax</span><span class="params">( BinTree BST )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST ) <span class="comment">// 结点不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( BST-&gt;Right ) <span class="comment">// 右儿子不空</span></span><br><span class="line">            BST = BST-&gt;Right; <span class="comment">// 则往右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最小元素在最左段上<br>递归法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Position <span class="title function_">FindMin</span><span class="params">( BinTree BST )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( !BST ) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">/*空的二叉搜索树，返回NULL*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( !BST-&gt;Left )</span><br><span class="line">        <span class="keyword">return</span> BST; <span class="comment">/*找到最左叶结点并返回*/</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> FindMin( BST-&gt;Left ); <span class="comment">/*沿左分支继续查找*/</span></span><br></pre></td></tr></table></figure><h2 id="插入">插入</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">Insert</span><span class="params">( ElementType X, BinTree BST )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( !BST ) <span class="comment">/*若原树为空，生成并返回一个结点的二叉搜索树*/</span></span><br><span class="line">    &#123; </span><br><span class="line">        BST = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode)); </span><br><span class="line">        BST-&gt;Data = X;            </span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/*开始找要插入元素的位置*/</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Left = Insert( X, BST-&gt;Left); <span class="comment">/*递归插入左子树*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Right = Insert( X, BST-&gt;Right); <span class="comment">/*递归插入右子树*/</span></span><br><span class="line">    <span class="comment">/* else X已经存在，什么都不做 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><ol start="2"><li><p>删除的是叶结点</p></li><li><p>删除的只有一个孩子的结点</p></li><li><p>要删除的结点右左右两棵子树,则:</p><p>右子树最小元素替代</p><p>左子树最大元素替代</p></li></ol><p>实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">Delete</span><span class="params">( BinTree BST, ElementType X )</span> </span><br><span class="line">&#123; </span><br><span class="line">    Position Tmp; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( !BST ) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到&quot;</span>); </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Left = Delete( BST-&gt;Left, X );   <span class="comment">/* 从左子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( X &gt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Right = Delete( BST-&gt;Right, X ); <span class="comment">/* 从右子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">/* BST就是要删除的结点 */</span></span><br><span class="line">            <span class="comment">/* 如果被删除结点有左右两个子结点 */</span> </span><br><span class="line">            <span class="keyword">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) &#123;</span><br><span class="line">                <span class="comment">/* 从右子树中找最小的元素填充删除结点 */</span></span><br><span class="line">                Tmp = FindMin( BST-&gt;Right );</span><br><span class="line">                BST-&gt;Data = Tmp-&gt;Data;</span><br><span class="line">                <span class="comment">/* 从右子树中删除最小元素 */</span></span><br><span class="line">                BST-&gt;Right = Delete( BST-&gt;Right, BST-&gt;Data );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">/* 被删除结点有一个或无子结点 */</span></span><br><span class="line">                Tmp = BST; </span><br><span class="line">                <span class="keyword">if</span>( !BST-&gt;Left )       <span class="comment">/* 只有右孩子或无子结点 */</span></span><br><span class="line">                    BST = BST-&gt;Right; </span><br><span class="line">                <span class="keyword">else</span>                   <span class="comment">/* 只有左孩子 */</span></span><br><span class="line">                    BST = BST-&gt;Left;</span><br><span class="line">                <span class="built_in">free</span>( Tmp );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>平衡二叉树  Balanced Binary Tree</h1><p>平均查找长度ASL<br>平衡因子(Balance Factor，简称BF): BF(T) = hL-hR，<br>|BF(T)| &lt;= 1<br>平衡二叉树的高度<br>n_h: 高度为h的平衡二叉树最少结点数<br>n_h = n_h-1 + n_h-2 + 1<br>= F_h+2 - 1<br>给定结点数为 n的AVL树的 最大高度为O(log2n)!</p><h2 id="调整">调整</h2><p>平衡二叉树是搜索树<br>右单旋<br>麻烦结点在发现者(被破坏者)的右子树的右子树上,因而RR插入,需要RR旋转<br>左单旋<br>麻烦结点在发现者(被破坏者)的左子树的左子树上,因而LL旋转<br>左右旋转<br>麻烦结点在发现者(被破坏者)的左子树的右子树上, LR旋转</p><p>习题: 是否同一颗二叉搜索树</p><ol start="2"><li>根据两个序列分别建树，再判别树是否一样</li><li>不建树的判别方法</li><li>建一棵树，再判别其他序列是否与该树一致</li></ol><h1>堆 Heap</h1><p>优先队列(Priority Queue)<br>结构性:用 <em>数组</em> 表示的完全二叉树;<br>有序性:任一结点的关键字是其子树所有结点的最大值(或最小值)<br>* “最大堆(MaxHeap)”,也称“大顶堆”:最大值<br>* “最小堆(MinHeap)”,也称“小顶堆” :最小值</p><p>主要操作有:<br>• MaxHeap Create( int MaxSize ):创建一个空的最大堆。<br>• Boolean IsFull( MaxHeap H ):判断最大堆H是否已满。<br>• Insert( MaxHeap H, ElementType item ):将元素item插入最大堆H。<br>• Boolean IsEmpty( MaxHeap H ):判断最大堆H是否为空。<br>• ElementType DeleteMax( MaxHeap H ):返回H中最大元素(高优先级)。</p><h2 id="结构">结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HNode</span> *<span class="title">MaxHeap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HNode</span> &#123;</span></span><br><span class="line">    ElementType *Elements; <span class="comment">// 存储堆元素的数组</span></span><br><span class="line">    <span class="type">int</span> Size;   <span class="comment">// 堆的当前元素的个数</span></span><br><span class="line">    <span class="type">int</span> Capacity  <span class="comment">// 堆的最大容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建">创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MaxHeap <span class="title function_">CreateHeap</span><span class="params">(<span class="type">int</span> Maxsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    MaxHeap H = (MaxHeap)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HNode));</span><br><span class="line">    H-&gt;Elements = <span class="built_in">malloc</span>((MaxSize+<span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType)); <span class="comment">// 因为这里是一个数组,需要分配空间</span></span><br><span class="line">    H-&gt;Size = <span class="number">0</span>; <span class="comment">// 当前是空的</span></span><br><span class="line">    H-&gt;Capacity = MaxSize;  <span class="comment">// 堆的最大容量</span></span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MaxSize; <span class="comment">/* 定义“哨兵”为大于堆中所有可能元素的值，便于以后操作 */</span></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入-2">插入</h2><p>将新增结点插入到从其父结点到根结点的有序序列中<br>将新item放在最后的位置Size+1, 然后跟他的父节点i/2比较,不断把父节点往下(子节点)移动,直到其父节点大于item</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertHeap</span><span class="params">(MaxHeap H, ElementType item)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (IsFull(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size;  <span class="comment">// H-&gt;Size++; i = H-&gt;Size; 把新增元素放在末尾H-&gt;Size++的位置上</span></span><br><span class="line">    <span class="keyword">for</span>(; H-&gt;Elements[i/<span class="number">2</span>] &lt; item; i/=<span class="number">2</span>)&#123;  <span class="comment">// 其父节点小于它</span></span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i/<span class="number">2</span>]; <span class="comment">// 把它的父节点,向下过滤, 插入的item向上过滤</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 当它的父结点[i/2]比它大的时候, 跳出循环</span></span><br><span class="line">    H-&gt;Elements[i] = item;  <span class="comment">// 填上item</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>删除</h1><p>取出根结点(最大值)元素，同时删除堆的一个结点。</p><ul><li>最后的元素替补根的位置</li><li>有序化, 父结点和更大的那个子结点比较,将子结点不断往上移, 直到父结点不子结点大</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">DeleteMax</span><span class="params">(MaxHeap H)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> parent, child;</span><br><span class="line">    ElementType MaxItem, temp;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MaxItem = H-&gt;Elements[<span class="number">1</span>]; <span class="comment">// 取出最大值</span></span><br><span class="line">    <span class="comment">/* 用最大堆中最后一个元素从根节点开始向上过滤下层节点 */</span></span><br><span class="line">    temp = H-&gt;Elements[Size];  <span class="comment">// 把堆中最后一个值,交给temp</span></span><br><span class="line">    Size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(parent=<span class="number">1</span>; parent*<span class="number">2</span> &lt;= H-&gt;Size; parent=child)</span><br><span class="line">    &#123;</span><br><span class="line">        child = parent*<span class="number">2</span>  <span class="comment">// 左儿子</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* child=左右儿子中大的那个, 当右儿子存在,且右儿子的值比左儿子大时,让child=右儿子 */</span></span><br><span class="line">        <span class="keyword">if</span>((child!= H-&gt;Size) &amp;&amp; </span><br><span class="line">        (H-&gt;Elements[child] &lt; H-&gt;Elements[child+<span class="number">1</span>])) </span><br><span class="line">            child++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 当temp比child的值大时跳出循环 */</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= Elements[child]) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child]; <span class="comment">//当parent &lt; child,这个parent位置上变为child的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp; </span><br><span class="line">    <span class="keyword">return</span> MaxItem; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>堆排序</h1><p>方法1:通过插入操作，将N个元素一个个相继插入到一个初 始为空的堆中去，其时间代价最大为O(N logN)。</p><p>方法2:在线性时间复杂度下建立最大堆。O(N)<br>(1)将N个元素按输入顺序存入，先满足完全二叉树的结构特性<br>(2)调整各结点位置，以满足最大堆的有序特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BuildHeap</span><span class="params">(MaxHeap H)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = H-&gt;Size/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--) </span><br><span class="line">    &#123;<span class="comment">// 从最后一个结点的父节点开始,到根节点为止</span></span><br><span class="line">        PercDown(H, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下滤函数, 将Maxheap中以H-&gt;Data[p]为根的子堆调整为最大堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PercDown</span><span class="params">( MaxHeap H, <span class="type">int</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> parent, child;</span><br><span class="line"></span><br><span class="line">    X = H-&gt;Data[p]; <span class="comment">// 取出根节点的值</span></span><br><span class="line">    <span class="keyword">for</span>(parent =  p; parent*<span class="number">2</span> &lt;= H-&gt;Size; parent = child)</span><br><span class="line">    &#123;</span><br><span class="line">        child = parent * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( (child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child+<span class="number">1</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (X &gt; H-&gt;Data[child]) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 将X下滤</span></span><br><span class="line">            H-&gt;Data[parent] = H-&gt;Data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data(parent) = X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>哈夫曼树与哈夫曼编码</h1><p>带权路径WPL Weighted Path Length)长度最小, 最优二叉树.<br>数据结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> Weight;</span><br><span class="line">    HaffmanTree left;</span><br><span class="line">    HaffmantREE Right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用最小堆进行构造:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HuffmanTree <span class="title function_">Huffman</span><span class="params">(MinHeap H)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    BuildMinHeap(H); <span class="comment">// 将H-&gt;Elements[]按照权重调整为最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i &lt; H-&gt;Size; i++) <span class="comment">// 做size-1次合并</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode)); <span class="comment">// 建立新结点</span></span><br><span class="line">        <span class="comment">/*从最小堆中删除一个结点，作为新T的左子结点*/</span></span><br><span class="line">        T-&gt;Left = DeleteMin(H);</span><br><span class="line">        T-&gt;Right = DeleteMin(H);</span><br><span class="line">        <span class="comment">/*计算新权值*/</span></span><br><span class="line">        T-&gt;Weight = T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight;</span><br><span class="line">        Insert( H, T ); <span class="comment">/*将新T插入最小堆*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    T = Deletemin(H); <span class="comment">// 最小堆中的最后一个元素就是指向Huffman树根节点的指针</span></span><br><span class="line">    <span class="keyword">return</span> T; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈夫曼树的特点:</p><ol><li>没有度为1的结点</li><li>n个叶子结点的哈夫曼树共有2n-1个结点;<br>因为: n2= n0 -1,<br>总结点数 = n0 + n2 = 2n0 - 1</li><li>哈夫曼树的任意非叶节点的左右子树交换后仍是哈夫曼树;</li><li>对同一组权值{w1 ,w2 , … , wn}，存在不同构的两</li></ol><h1>集合及运算</h1><p>双亲表示法: 孩子指向父节点<br>数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    ElementType Data; </span><br><span class="line">    <span class="type">int</span> Parent;  <span class="comment">// 其父节点的下标</span></span><br><span class="line">&#125; SetType;</span><br></pre></td></tr></table></figure><h2 id="查找某个元素所在的集合">查找某个元素所在的集合</h2><p>用根节点表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(SetType S[], ElementType X)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 在数组S中查找值为X的元素所属的集合, MaxSize为数组最大长度 */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;MaxSize &amp;&amp; S[i].Data != X; i++)</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= MaxSize) <span class="comment">// 未找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; S[i].Parent &gt;= <span class="number">0</span>; i = s[i].Parent);  <span class="comment">// 向上找它的父节点</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合的并运算">集合的并运算</h2><p>如果它们不同根，则将其中一个根结点的父结点指针设置成<br>另一个根结点的数组下标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">( SetType S[], ElementType X1, ElementType X2 )</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Root1, Root2;</span><br><span class="line">    Root1 = Find(S, X1);</span><br><span class="line">    Root2 = Find(S, X2);</span><br><span class="line">    <span class="keyword">if</span>( Root1 != Root2 )</span><br><span class="line">        S[Root2].Parent = Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使树更矮,合并时按秩合并<br>直接用一个数组表示,不用之前的数据结构了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000                  <span class="comment">/* 集合最大元素个数 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;           <span class="comment">/* 默认元素可以用非负整数表示 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SetName;               <span class="comment">/* 默认用根结点的下标作为集合名称 */</span></span><br><span class="line"><span class="keyword">typedef</span> ElementType SetType[MAXN]; <span class="comment">/* 假设集合元素下标从0开始 */</span></span><br><span class="line"></span><br><span class="line">SetName <span class="title function_">Find</span><span class="params">(SetType S, ElementType X)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; S[X] &gt; <span class="number">0</span>; X=S[X]);</span><br><span class="line">    <span class="keyword">return</span> X.</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> OldUnion(SetType S, SetName Root1, SetName Root2)&#123;</span><br><span class="line">    S[Root2] = Root1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">( SetType S, SetName Root1, SetName Root2 )</span></span><br><span class="line">&#123; <span class="comment">/* 这里默认Root1和Root2是不同集合的根结点 */</span></span><br><span class="line">    <span class="comment">/* 保证小集合并入大集合 */</span></span><br><span class="line">    <span class="keyword">if</span> ( S[Root2] &lt; S[Root1] ) &#123; <span class="comment">/* 如果集合2比较大 */</span></span><br><span class="line">        S[Root2] += S[Root1];     <span class="comment">/* 集合1并入集合2  */</span></span><br><span class="line">        S[Root1] = Root2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">/* 如果集合1比较大 */</span></span><br><span class="line">        S[Root1] += S[Root2];     <span class="comment">/* 集合2并入集合1  */</span></span><br><span class="line">        S[Root2] = Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径压缩</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SetName <span class="title function_">Find</span><span class="params">( SetType S, ElementType X )</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> ( S[X] &lt; <span class="number">0</span> ) <span class="comment">/* 找到集合的根 */</span></span><br><span class="line">        <span class="keyword">return</span> X;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> S[X] = Find( S, S[X] ); <span class="comment">/* 路径压缩 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>图 Graph</h1><p>顶点的集合 V (Vertex)<br>边的集合 E (Edge)</p><ul><li>邻接矩阵<br>用一个长度为N(N+1)/2的1维数组A存储<br>O(N^2)</li><li>邻接表<br>G[N]为指针数组，对应矩阵每行一个链表， 只存非0元素<br>O(N+E)</li></ul><h2 id="建立图">建立图</h2><p>邻接矩阵</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用全局变量建图</span></span><br><span class="line"><span class="type">int</span> G[MAXN][MAXN], Nv, Ne; </span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildGraph</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i,j,v1,v2,w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Nv);</span><br><span class="line">    <span class="comment">/* CreateGraph */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;Nv; i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;Nv; j++)</span><br><span class="line">            G[i][j] = <span class="number">0</span>; <span class="comment">/* 或INFINITY */</span> </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Ne);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;Ne; i++) &#123;</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;v1, &amp;v2, &amp;w);</span><br><span class="line">         <span class="comment">/* InsertEdge */</span></span><br><span class="line">        G[v1][v2] = w;</span><br><span class="line">        G[v2][v1] = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的遍历">图的遍历</h2><h3 id="深度优先搜索-Depth-First-Search-DFS">深度优先搜索(Depth First Search, DFS)</h3><p>类似于树的先序遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span> <span class="params">( Vertex V )</span></span><br><span class="line">&#123; </span><br><span class="line">    visited[V] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> ( V 的每个邻接点 W ) </span><br><span class="line">        <span class="keyword">if</span> ( !visited[W] )</span><br><span class="line">            DFS(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<br>以V为出发点对邻接表存储的图Graph进行DFS搜索</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Visit</span><span class="params">( Vertex V )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在访问顶点%d\n&quot;</span>, V);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">( LGraph Graph, Vertex V, <span class="type">void</span> (*Visit)(Vertex) )</span></span><br><span class="line">&#123;  </span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    Visit( V ); </span><br><span class="line">    Visited[V] = <span class="literal">true</span>; </span><br><span class="line">    <span class="comment">/* 对V的每个邻接点W-&gt;AdjV */</span></span><br><span class="line">    <span class="keyword">for</span>( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) </span><br><span class="line">        <span class="keyword">if</span> ( !Visited[W-&gt;AdjV] )    </span><br><span class="line">            DFS( Graph, W-&gt;AdjV, Visit );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索-Breadth-First-Search-BFS">广度优先搜索(Breadth First Search, BFS)</h3><p>层序遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span> <span class="params">( Vertex V )</span></span><br><span class="line">&#123; </span><br><span class="line">    visited[V] = <span class="literal">true</span>;</span><br><span class="line">    Enqueue(V, Q);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        <span class="keyword">for</span> ( V 的每个邻接点 W )        </span><br><span class="line">            <span class="keyword">if</span> ( !visited[W] ) </span><br><span class="line">            &#123;</span><br><span class="line">                visited[W] = <span class="literal">true</span>;</span><br><span class="line">                Enqueue(W, Q);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br></pre></td></tr></table></figure><p>实现 邻接矩阵存储的图 - BFS</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEdge</span><span class="params">( MGraph Graph, Vertex V, Vertex W )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Graph-&gt;G[V][W]&lt;INFINITY ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Visited[]为全局变量，已经初始化为false */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span> <span class="params">( MGraph Graph, Vertex S, <span class="type">void</span> (*Visit)(Vertex) )</span></span><br><span class="line">&#123;   <span class="comment">/* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 */</span></span><br><span class="line">    Queue Q;     </span><br><span class="line">    Vertex V, W;</span><br><span class="line"> </span><br><span class="line">    Q = CreateQueue( MaxSize ); <span class="comment">/* 创建空队列, MaxSize为外部定义的常数 */</span></span><br><span class="line">    <span class="comment">/* 访问顶点S：此处可根据具体访问需要改写 */</span></span><br><span class="line">    Visit( S );</span><br><span class="line">    Visited[S] = <span class="literal">true</span>; <span class="comment">/* 标记S已访问 */</span></span><br><span class="line">    AddQ(Q, S); <span class="comment">/* S入队列 */</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span> ( !IsEmpty(Q) ) &#123;</span><br><span class="line">        V = DeleteQ(Q);  <span class="comment">/* 弹出V */</span></span><br><span class="line">        <span class="keyword">for</span>( W=<span class="number">0</span>; W&lt;Graph-&gt;Nv; W++ ) <span class="comment">/* 对图中的每个顶点W */</span></span><br><span class="line">            <span class="comment">/* 若W是V的邻接点并且未访问过 */</span></span><br><span class="line">            <span class="keyword">if</span> ( !Visited[W] &amp;&amp; IsEdge(Graph, V, W) ) &#123;</span><br><span class="line">                <span class="comment">/* 访问顶点W */</span></span><br><span class="line">                Visit( W );</span><br><span class="line">                Visited[W] = <span class="literal">true</span>; <span class="comment">/* 标记W已访问 */</span></span><br><span class="line">                AddQ(Q, W); <span class="comment">/* W入队列 */</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="comment">/* while结束*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p># 最短路径</p><p>在网络中，求两个不同顶点之间的所有路径 中，边的权值之和最小的那一条路径</p><p>## 无权图的单源最短路算法</p><p>按照递增(非递减)的顺序找出到各个顶 点的最短路</p><p>伪码描述:</p><p>```c</p><p>void Unweighted ( Vertex S )</p><p>{</p><p>Enqueue(S, Q);</p><p>while(!IsEmpty(Q)){</p><p>V = Dequeue(Q);</p><p>for ( V 的每个邻接点 W )</p><p>if(dist[W]==-1 ){</p><p>dist[W] = dist[V]+1;</p><p>path[W] = V;</p><p>Enqueue(W, Q);</p><p>}</p><p>}</p><p>}</p><p>```</p><p>实现</p><p>无权图的单源最短路算法 -  邻接表存储</p><p>dist[] path[]全部初始化为-1</p><p>```c</p><p>void Unweighted(LGraph Graph, int dist[], int path[], Vertex S){</p><p>Queue Q;</p><p>Vertex V;</p><p>PtrAdjVNode W;</p><p>Q = CreateQueue(Graph-&gt;Nv);  // 创建空队列,MaxSize为外部定义的常数</p><p>dist[S] = 0; // 初始化源点</p><p>AddQ(Q, S);</p><p>while (IsEmpty(Q))</p><p>{</p><p>V = DeleteQ(Q);</p><p>for( W = Graph.G[V].FirstEdge; W; W=W-&gt;Next)  // 对V的每个邻接点W-&gt;AdjV</p><p>if (dist[W-&gt;AdjV] == -1)</p><p>{  // W-&gt;AdjV 未被访问过</p><p>dist[W-&gt;AdjV] =dist[V] + 1;  /* W-&gt;AdjV到S的距离更新 */</p><p>path[W-&gt;AdjV] = V; /* 将V记录在S到W-&gt;AdjV的路径上 */</p><p>AddQ(Q, W-&gt;AdjV);</p><p>}</p><p>}</p><p>}</p><p>```</p><p>## 有权图的单源最短路算法</p><p>Dijkstra 算法</p><p>按照递增的顺序找出到各个顶点的最短路</p><ul><li>真正的最短路必须只经过S中的顶点</li><li>每次从未收录的顶点中选一个dist最小的收录</li><li>增加一个v进入S，可能影响另外一个w的dist值</li></ul><ol><li>dist[w] = min{dist[w], dist[v] + &lt;v,w&gt;的权重}</li></ol><p>伪码</p><p>```c</p><p>void Dijkstra( Vertex s )</p><p>{</p><p>while (1){</p><p>V = 未收录顶点中dist最小者;</p><p>if ( 这样的V不存在 )</p><p>break;</p><p>collected[V] = true;</p><p>for ( V 的每个邻接点 W ){</p><p>if ( collected[W] == false ){</p><p>if ( dist[V]+E&lt;V,W&gt; &lt; dist[W] ) {</p><p>dist[W] = dist[V] + E&lt;V,W&gt; ;</p><p>path[W] = V;</p><p>}</p><p>}</p><p>}</p><p>}</p><p>}</p><p>```</p><p>算法实现</p><p>邻接矩阵存储 - 有权图的单源最短路算法</p><p>```c</p><p>// 返回未被收录顶点中dist最小值</p><p>Vertex FindMinDist(MGraph Graph, int dist[], int collected[]){</p><p>Vertex MinV, V;</p><p>int MinDist = INFINITY;</p><p>for(V=0; V<Graph->Nv; V++){</p><p>if (collected[V] = false &amp;&amp; dist[V]&lt; MinDist){  /* 若V未被收录，且dist[V]更小 */</p><p>MinDist = dist[V];</p><p>MinV = V;  /* 更新对应顶点 */</p><p>}</p><p>}</p><p>if (MinDist &lt; INFINITY) /* 若找到最小dist */</p><p>return MinV; /* 返回对应的顶点下标 */</p><p>else return ERROR;  /* 若这样的顶点不存在，返回错误标记 */</p><p>}</p><p>bool Dijkstra(MGraph Graph, int dist[], int path[], Vertex S)</p><p>{</p><p>int collected[MaxVertexNum];</p><p>Vertex V, W;</p><p>// 初始化dist[]和path[],邻接矩阵中不存在边的标记为INFINITY</p><p>for(V=0; V<Graph->Nv; V++){</p><p>dist[V] = Graph-&gt;G[S][V];</p><p>if (dist[V]&lt;INFINITY)  // S到V有直接路径</p><p>path[V] = S;</p><p>else</p><p>path[V] = -1;</p><p>collected[V] = false;</p><p>}</p><p>// 先将起点收入到集合中</p><p>dist[S] = 0;</p><p>collected[S] = true;</p><p>while(1)</p><p>{</p><p>V = FindMinDist(Graph, dist, collected); /* V = 未被收录顶点中dist最小者 */</p><p>if (V == ERROR)  /* 若这样的V已经不存在 */</p><p>break;</p><p>collected[V] = true;</p><p>for(W=0; W<Graph->Nv; W++){ // 对图中的每个顶点W</p><p>if(collected[W] == false &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY)</p><p>{  // 未被收录,且有边(是邻接点)</p><p>if ( Graph-&gt;G[V][W]&lt;0 ) /* 若有负边 */</p><p>return false; /* 不能正确解决，返回错误标记 */</p><p>/* 若收录V使得dist[W]变小 */</p><p>if ( dist[V]+Graph-&gt;G[V][W] &lt; dist[W] ) {</p><p>dist[W] = dist[V]+Graph-&gt;G[V][W]; /* 更新dist[W] */</p><p>path[W] = V; /* 更新S到W的路径 */</p><p>}</p><p>}</p><p>} // for循环结束, 每个V的邻接点W遍历完</p><p>}// while结束</p><p>return true;</p><p>}</p><p>```</p><p>## 多源最短路算法</p><p>Floyd 算法</p><p>```c</p><p>bool Floyd( MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum] )</p><p>{</p><p>Vertex i, j, k;</p><p>/* 初始化 */</p><p>for ( i=0; i<Graph->Nv; i++ )</p><p>for( j=0; j<Graph->Nv; j++ ) {</p><p>D[i][j] = Graph-&gt;G[i][j];</p><p>path[i][j] = -1;</p><p>}</p><p>for( k=0; k<Graph->Nv; k++ )</p><p>for( i=0; i<Graph->Nv; i++ )</p><p>for( j=0; j<Graph->Nv; j++ )</p><p>if( D[i][k] + D[k][j] &lt; D[i][j] ) {</p><p>D[i][j] = D[i][k] + D[k][j];</p><p>if ( i==j &amp;&amp; D[i][j]&lt;0 ) /* 若发现负值圈 */</p><p>return false; /* 不能正确解决，返回错误标记 */</p><p>path[i][j] = k;</p><p>}</p><p>return true; /* 算法执行完毕，返回正确标记 */</p><p>}</p><p>```</p><p># 排序</p><p>## 冒泡排序</p><p>稳定!</p><p>最好情况:顺序 T = O(N)</p><p>最坏情况:逆序 T = O(N^2)</p><p>```c</p><p>void Swap(ElementType *a, ElementType *b){</p><p>ElementType c;</p><p>c = *a;</p><ul><li>a = *b;</li><li>b = c;</li></ul><p>}</p><p>void Bubble_Sort(ElementType A[], int N){</p><p>int P, i, flag;</p><p>for (P=N-1; P&gt;0; P–){  // 最后一位下标是N-1</p><p>flag = 0;</p><p>for (i=0; i&lt;P; i++){</p><p>if(A[i] &gt; A[i+1]){</p><p>Swap(&amp;A[i], &amp;A[i+1]);</p><p>flag = 1;  // 标识发生了交换</p><p>}</p><p>}</p><p>if (flag==0)</p><p>break; // 若全程无交换</p><p>}</p><p>}</p><p>```</p><p>## 插入排序</p><p>稳定!</p><p>最好情况:顺序 T = O(N)</p><p>最坏情况:逆序 T = O(N^2)</p><p>时间复杂度和逆序对有关 T(N,I) = O(N+I)</p><p>定理: 任意N个不同元素组成的序列平均具有 N ( N -1 ) / 4 个逆序对。</p><p>简单排序(交换相邻两个数)的时间复杂度下界: Omega(N^2)</p><p>```c</p><p>void Insertion_Sort(ElementType A[], int N){</p><p>ElementType Tmp;</p><p>int P, i;</p><p>for(P=1; P&lt;N; P++){</p><p>Tmp = A[P]; // 摸下一张牌</p><p>for (i = P; i&gt;0; i–)</p><p>{</p><p>if(A[i-1] &gt; Tmp) // 若前一张牌比新摸的牌大</p><p>A[i] = A[i-1]; // 移出空位</p><p>else break;  // 若新摸的牌比前一张牌大,则跳出循环</p><p>}</p><p>A[i] = Tmp; // 新牌落位</p><p>}</p><p>}</p><p>```</p><p>## 希尔排序</p><p>不稳定!</p><p>定义增量序列,如Sedgewick增量序列{1,5,19,41,109…}</p><p>对每个D进行D间隔的排序</p><p>```c</p><p>void Shell_Sort(ElementType A[], int N){</p><p>int D, P,i;</p><p>ElementType Tmp;</p><p>for (D=N/2; D&gt;0; D/=2){ // 希尔排序增量</p><p>for ( P=D; P&lt;N; P++){  // 插入排序</p><p>Tmp = A[P];</p><p>for (i = P; i-D&gt;=0; i-=D)</p><p>{</p><p>if(A[i-D] &gt; Tmp)</p><p>A[i] = A[i-D]; // 移出空位</p><p>else break;</p><p>}</p><p>A[i] = Tmp; // 新牌落位</p><p>}</p><p>}</p><p>}</p><p>```</p><p>## 堆排序</p><p>不稳定!</p><p>选择排序:</p><p>```c</p><p>void Selection_Sort ( ElementType A[], int N )</p><p>{</p><p>for(i=0;i&lt;N;i++){</p><p>MinPosition = ScanForMin( A, i, N–1 );</p><p>Swap( A[i], A[MinPosition] );</p><p>}</p><p>}</p><p>```</p><p>重要的是如何找到最小元.</p><p>堆排序处理N个不同元素的 随机排列的平均比较次数是2NlogN - O(NloglogN)</p><p>用最大堆,交换根节点和最后一个结点,让最大的数到最后,然后减小堆的规模</p><p>```c</p><p>void PercDown(ElementType A[] , int p, int N)</p><p>{// 下滤函数, 将Minheap中以H-&gt;Data[p]为根的子堆调整为最小堆</p><p>int parent, child;</p><p>ElementType X;</p><p>X = A[p]; // 取出根节点的值</p><p>for(parent =  p; parent*2+1 &lt;= N-1 ; parent = child)</p><p>{</p><p>child = parent*2+1;</p><p>if( (child != N-1 ) &amp;&amp; (A[child] &lt; A[child+1]))</p><p>{</p><p>child++;</p><p>}</p><p>if (X &gt;= A[child])</p><p>break;</p><p>else // 将X下滤</p><p>A[parent] = A[child];</p><p>}</p><p>A[parent] = X;</p><p>}</p><p>void Heap_Sort(ElementType A[], int N){</p><p>int i;</p><p>for (i=N/2; i&gt;=0; i–)  // Build MaxHeap</p><p>PercDown(A, i, N);</p><p>for (i=N-1; i&gt;0; i–){</p><p>Swap(&amp;A[0], &amp;A[i]);  // DeleteMax</p><p>PercDown(A, 0, i);  // 重新整理成最大堆,堆的size为i</p><p>}</p><p>}</p><p>```</p><p>## 归并排序</p><p>稳定!</p><p>有序子列的归并</p><p>```c</p><p>void Merge(ElementType A[], ElementType TmpA[],</p><p>int L, int R, int RightEnd)</p><p>{</p><p>int LeftEnd, Num, Tmp;</p><p>int i;</p><p>LeftEnd = R - 1;</p><p>Tmp = L;  // 存放结果的数组的初始位置</p><p>Num = RightEnd - L + 1; // 一共有几个数据</p><p>while (L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd){  // 左和右都不为空</p><p>if (A[L] &lt;= A[R])</p><p>TmpA[Tmp++] = A[L++];</p><p>else</p><p>TmpA[Tmp++] = A[R++];</p><p>}</p><p>// 跳出循环时左边还有剩下的</p><p>while (L &lt;= LeftEnd)</p><p>TmpA[Tmp++] = A[L++];</p><p>// 跳出循环时右边还有剩下的</p><p>while (R &lt;= RightEnd)</p><p>TmpA[Tmp++] = A[R++];</p><p>// 把TmpA倒回到A, 从RightEnd倒着复制回去</p><p>for(i=0; i&lt;Num; i++){  // 重复Num次</p><p>A[RightEnd] = TmpA[RightEnd];</p><p>RightEnd–;</p><p>}</p><p>}</p><p>```</p><p>递归算法:</p><p>```c</p><p>void MSort(ElementType A[], ElementType TmpA[], int L, int RightEnd)</p><p>{</p><p>int Center;</p><p>if(L &lt; RightEnd){  // L和RightEnd相等时,就只有一个元素了,不能再分</p><p>Center = (L+RightEnd)/2;</p><p>// 分</p><p>MSort(A, TmpA, L, Center);</p><p>MSort(A, TmpA, Center+1, RightEnd);</p><p>// 合</p><p>Merge(A, TmpA, L, Center+1, RightEnd);</p><p>}</p><p>}</p><p>// 同一接口</p><p>void Merge_Sort(ElementType A[], int N){</p><p>ElementType *TmpA;  // 临时数组</p><p>TmpA = malloc(N * sizeof(ElementType));</p><p>if (TmpA != NULL){  // 分配空间成功</p><p>MSort(A, TmpA, 0, N-1);</p><p>free(TmpA);</p><p>}</p><p>else</p><p>printf(“空间不足\n”);</p><p>}</p><p>```</p><p>T(N) = T(N/2) + T(N/2) + O(N)</p><p>T(N) = O(NlogN)</p><p>非递归算法</p><p>```c</p><p>void Merge_Pass(ElementType A[], ElementType TmpA[], int N, int length)  // lenght = 当前有序子列的长度, 一开始等于1</p><p>{</p><p>int i,j;</p><p>for (i=0; i &lt;= N-2*length; i+=2*length) // 留两个length,分情况讨论</p><p>Merge(A, TmpA, i, i+length, i+2*length-1); // A TmpA L R RightEnd</p><p>if (i+length &lt; N) // 归并最后两个子列</p><p>Merge(A, TmpA, i, i+length, N-1);</p><p>else  // 最后只剩一个子列, 则复制过来</p><p>for (j=i; j&lt;N; j++)</p><p>TmpA[j] = A[j];</p><p>}</p><p>void Merge_sort(ElementType A[], int N){</p><p>int length = 1;  // 初始化子序列的长度</p><p>ElementType *TmpA;  // 临时数组</p><p>TmpA = malloc(N * sizeof(ElementType));</p><p>if (TmpA != NULL){  // 分配空间成功</p><p>while (length &lt; N){  // 有序子列长度等于N,则完成,跳出循环</p><p>Merge_Pass(A, TmpA, N, length);</p><p>length *= 2;</p><p>Merge_Pass(TmpA, A, N, length);</p><p>length *= 2;</p><p>}</p><p>free(TmpA);</p><p>}</p><p>else</p><p>printf(“空间不足\n”);</p><p>}</p><p>```</p><p>归并排序是稳定的</p><p>## 快速排序</p><p>不稳定</p><p>主元一次性放到正确的位置上</p><p>主元左边的都比主元小,右边的都比主元大</p><p>```c</p><p>// 选主元 pivot</p><p>ElementType Median3(ElementType A[], int Left, int Right){</p><p>int Center = (Left + Right) / 2;</p><p>// 整理成 A[Left] &lt;= A[Center] &lt;= A[Right]</p><p>if (A[Left] &gt; A[Center])</p><p>Swap(&amp;A[Left], &amp;A[Right]);</p><p>if (A[Left] &gt; A[Right])</p><p>Swap(&amp;A[Left], &amp;A[Right]);</p><p>if (A[Center] &gt; A[Right])</p><p>Swap(&amp;A[Center], &amp;A[Right]);</p><p>// 将基准Pivot藏到右边Right-1处, 则之后只需考虑 A[Left+1] -&gt; A[Right-2]</p><p>Swap(&amp;A[Center], &amp;A[Right-1]);</p><p>return A[Right-1];</p><p>}</p><p>void Qsort(ElementType A[], int Left, int Right){</p><p>int Pivot, Cutoff, Low, High;</p><p>// 如果序列元素足够多,则进入快排</p><p>Cutoff = 4;</p><p>if (Cutoff &lt;= Right - Left){</p><p>Pivot = Median3(A, Left, Right);</p><p>Low = Left;</p><p>High = Right-1;</p><p>while(1){</p><p>while(A[++Low] &lt; Pivot);  // 一直循环,直到A[Low] &gt;= Pivot, 停住</p><p>while(A[–High] &gt; Pivot);  // 一直循环,直到A[Hight] &lt;= Pivot, 停住</p><p>if (Low&lt;High)</p><p>Swap(&amp;A[Low], &amp;A[High]);</p><p>else // Low &gt; High low已经越过了high,子序列排序结束</p><p>break;</p><p>}</p><p>Swap(&amp;A[Low], &amp;A[Right-1]);  // 将Pivot归位,此时 Low&gt;High, 所以Pivot和Low交换</p><p>Qsort(A, Left, Low-1);   // 递归Pivot左边</p><p>Qsort(A, Low+1, Right);    // 递归Pivot右边</p><p>}</p><p>else // 元素太少,用简单排序</p><p>Insertion_Sort(A+Left, Right-Left+1);  // 待排序列表A从Left开始,即A+Left, 长度是R-L+1</p><p>}</p><p>void Quick_Sort(ElementType A[], int N){</p><p>Qsort(A, 0 ,N-1);</p><p>}</p><p>```</p><p>## 选择排序</p><p>不稳定</p><p>```c</p><p>#define MaxDigit 3  // 假设最大为三位数</p><p>#define Radix 10  // 十进制</p><p>/* 桶元素结点 */</p><p>typedef struct Node *PtrNode;</p><p>struct Node</p><p>{</p><p>int key;</p><p>PtrNode next;</p><p>};</p><p>/* 桶头结点 */</p><p>struct HeadNode</p><p>{</p><p>PtrNode head;</p><p>PtrNode tail;</p><p>};</p><p>typedef struct HeadNode Bucket[Radix];</p><p>/* 返回整型关键字X的第D位数字 */</p><p>int GetDigit(int X, int D){</p><p>// 默认次位D=1, 主位 D&lt;= MaxDigit</p><p>int d, i;</p><p>for(i=1; i&lt;=D; i++){</p><p>d = X % Radix;</p><p>X /= Radix;</p><p>}</p><p>return d;</p><p>}</p><p>// 次位优先(Least Significant Digit)排序</p><p>void LSDRadix_Sort(ElementType A[], int N){</p><p>int D, Di, i;</p><p>Bucket B;</p><p>PtrNode tmp, p, List=NULL;</p><p>// 初始化每个桶为空链表</p><p>for(i=0; i&lt;Radix; i++)</p><p>B[i].head = B[i].tail = NULL;</p><p>// 将原始序列A[], 逆序(插在链表头)存入链表List</p><p>for(i=0; i&lt;N; i++){</p><p>tmp = (PtrNode)malloc(sizeof(struct Node));</p><p>tmp-&gt;key = A[i];</p><p>tmp-&gt;next = List;</p><p>List = tmp;</p><p>}</p><p>// 开始排序</p><p>for (D=1; D&lt;= MaxDigit; D++){  // 对数据的每一位循环处理</p><p>p=List;</p><p>while(p)</p><p>{</p><p>Di = GetDigit(p-&gt;key, D);  // 获得当前元素的第D位数字</p><p>// 从链表P中删除结点</p><p>tmp = p;</p><p>p = p-&gt;next;</p><p>tmp-&gt;next = NULL;</p><p>// 把结点插入到对应的B[Di]桶里</p><p>if (B[Di].head == NULL)</p><p>B[Di].head = B[Di].tail = tmp;</p><p>else{</p><p>B[Di].tail-&gt;next = tmp; // 把tmp加在尾部</p><p>B[Di].tail = tmp;  // 尾部指向最后一个结点,即tmp</p><p>}</p><p>}  // while循环结束, 以第D位的分配完毕</p><p>// D位数排完以后开始收集</p><p>List = NULL;</p><p>for(Di=Radix-1; Di &gt;= 0; Di–)  // 将诶个桶的元素顺序收入List, 因为每次插入到List的头部,所以要从9开始收</p><p>{</p><p>if (B[Di].head){</p><p>B[Di].tail-&gt;next = List;</p><p>List = B[Di].head;</p><p>B[Di].head = B[Di].tail = NULL;  // 清空桶</p><p>}</p><p>}</p><p>}// 大for循环结束</p><p>// 将List[]导入A[], 并释放空间</p><p>for(i=0; i&lt;N; i++){</p><p>tmp = List;</p><p>List = List-&gt;next;</p><p>A[i] = tmp-&gt;key;</p><p>free(tmp);</p><p>}</p><p>}</p><p>```</p><p>时间复杂度 T = O(P(N+B))</p><p>当B较小时,基本是线性的.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;基本概念&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;空间使用&lt;br&gt;
函数PrintN，使得传入一个正整数为N的参数后，打印从1到N的全部正整数。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;</summary>
      
    
    
    
    <category term="code" scheme="https://qaqan.cn/categories/code/"/>
    
    
  </entry>
  
  <entry>
    <title>靡不有初，鲜克有终</title>
    <link href="https://qaqan.cn/2024/10/05/%E9%9D%A1%E4%B8%8D%E6%9C%89%E5%88%9D%EF%BC%8C%E9%B2%9C%E5%85%8B%E6%9C%89%E7%BB%88/"/>
    <id>https://qaqan.cn/2024/10/05/%E9%9D%A1%E4%B8%8D%E6%9C%89%E5%88%9D%EF%BC%8C%E9%B2%9C%E5%85%8B%E6%9C%89%E7%BB%88/</id>
    <published>2024-10-04T17:24:18.000Z</published>
    <updated>2025-07-30T10:40:48.940Z</updated>
    
    <content type="html"><![CDATA[<p>似乎下定了很多次决心来写博客，一直没有坚持下去。固然，“生活是沉闷和孤单的总和”，现实的平淡乏味是写文章最大的阻力。但我想，一定有一些东西是可以被纪念而成文的。</p><span id="more"></span><p>曾经记下的东西是如此冗杂：看演出、拍景色、偶尔发奋，无病呻吟。我不怀疑那些写下又很快删掉的文字的确出自真心，只是某个瞬间的强烈感情只在当时有意义。值得写下的到底是什么东西？至少可以做排除法：一定不是嘈杂的呐喊、一定不是做作地顾影自怜、一定不是要写给别人看的东西。<br>区别于其他社交媒体，我希望博客能让我更加关心文字本身，而不需要依靠九宫格、emoji、表情包和流行梗。对流行介质的过度依赖，会萎缩我的喉舌。</p><p>我相信仍有一些东西能让我产生“写点什么”的欲望：让我觉得一生只会激荡起一次的感情、跟人们产生的交际、特别幸福和特别难过的时刻。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;似乎下定了很多次决心来写博客，一直没有坚持下去。固然，“生活是沉闷和孤单的总和”，现实的平淡乏味是写文章最大的阻力。但我想，一定有一些东西是可以被纪念而成文的。&lt;/p&gt;</summary>
    
    
    
    <category term="post" scheme="https://qaqan.cn/categories/post/"/>
    
    
  </entry>
  
</feed>
